// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/hd_map.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2fhd_5fmap_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2fhd_5fmap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "apa_msgs/common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2fhd_5fmap_2eproto

namespace protobuf_apa_5fmsgs_2fhd_5fmap_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[1];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2fhd_5fmap_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class HDMap;
class HDMapDefaultTypeInternal;
extern HDMapDefaultTypeInternal _HDMap_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::HDMap *Arena::CreateMaybeMessage<::raincom::apa::msgs::HDMap>(
    Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

// ===================================================================

class HDMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.HDMap)
                                                  */
{
  public:
    HDMap();
    virtual ~HDMap();

    HDMap(const HDMap &from);

    inline HDMap &operator=(const HDMap &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    HDMap(HDMap &&from) noexcept : HDMap() { *this = ::std::move(from); }

    inline HDMap &operator=(HDMap &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const HDMap &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const HDMap *internal_default_instance()
    {
        return reinterpret_cast<const HDMap *>(&_HDMap_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(HDMap *other);
    friend void swap(HDMap &a, HDMap &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline HDMap *New() const final { return CreateMaybeMessage<HDMap>(NULL); }

    HDMap *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<HDMap>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const HDMap &from);
    void MergeFrom(const HDMap &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(HDMap *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .raincom.apa.msgs.Pose trj_points = 2;
    int trj_points_size() const;
    void clear_trj_points();
    static const int kTrjPointsFieldNumber = 2;
    ::raincom::apa::msgs::Pose *mutable_trj_points(int index);
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Pose>
        *mutable_trj_points();
    const ::raincom::apa::msgs::Pose &trj_points(int index) const;
    ::raincom::apa::msgs::Pose *add_trj_points();
    const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Pose> &trj_points()
        const;

    // string name = 3;
    void clear_name();
    static const int kNameFieldNumber = 3;
    const ::std::string &name() const;
    void set_name(const ::std::string &value);
#if LANG_CXX11
    void set_name(::std::string &&value);
#endif
    void set_name(const char *value);
    void set_name(const char *value, size_t size);
    ::std::string *mutable_name();
    ::std::string *release_name();
    void set_allocated_name(::std::string *name);

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // .raincom.apa.msgs.Pose start = 4;
    bool has_start() const;
    void clear_start();
    static const int kStartFieldNumber = 4;

  private:
    const ::raincom::apa::msgs::Pose &_internal_start() const;

  public:
    const ::raincom::apa::msgs::Pose &start() const;
    ::raincom::apa::msgs::Pose *release_start();
    ::raincom::apa::msgs::Pose *mutable_start();
    void set_allocated_start(::raincom::apa::msgs::Pose *start);

    // .raincom.apa.msgs.Pose slot = 5;
    bool has_slot() const;
    void clear_slot();
    static const int kSlotFieldNumber = 5;

  private:
    const ::raincom::apa::msgs::Pose &_internal_slot() const;

  public:
    const ::raincom::apa::msgs::Pose &slot() const;
    ::raincom::apa::msgs::Pose *release_slot();
    ::raincom::apa::msgs::Pose *mutable_slot();
    void set_allocated_slot(::raincom::apa::msgs::Pose *slot);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.HDMap)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Pose> trj_points_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::raincom::apa::msgs::Header *header_;
    ::raincom::apa::msgs::Pose *start_;
    ::raincom::apa::msgs::Pose *slot_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fhd_5fmap_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// HDMap

// .raincom.apa.msgs.Header header = 1;
inline bool HDMap::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &HDMap::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &HDMap::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.HDMap.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *HDMap::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.HDMap.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *HDMap::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.HDMap.header)
    return header_;
}
inline void HDMap::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.HDMap.header)
}

// repeated .raincom.apa.msgs.Pose trj_points = 2;
inline int HDMap::trj_points_size() const { return trj_points_.size(); }
inline ::raincom::apa::msgs::Pose *HDMap::mutable_trj_points(int index)
{
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.HDMap.trj_points)
    return trj_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Pose>
    *HDMap::mutable_trj_points()
{
    // @@protoc_insertion_point(field_mutable_list:raincom.apa.msgs.HDMap.trj_points)
    return &trj_points_;
}
inline const ::raincom::apa::msgs::Pose &HDMap::trj_points(int index) const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.HDMap.trj_points)
    return trj_points_.Get(index);
}
inline ::raincom::apa::msgs::Pose *HDMap::add_trj_points()
{
    // @@protoc_insertion_point(field_add:raincom.apa.msgs.HDMap.trj_points)
    return trj_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Pose>
    &HDMap::trj_points() const
{
    // @@protoc_insertion_point(field_list:raincom.apa.msgs.HDMap.trj_points)
    return trj_points_;
}

// string name = 3;
inline void HDMap::clear_name()
{
    name_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &HDMap::name() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.HDMap.name)
    return name_.GetNoArena();
}
inline void HDMap::set_name(const ::std::string &value)
{

    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.HDMap.name)
}
#if LANG_CXX11
inline void HDMap::set_name(::std::string &&value)
{

    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                     ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:raincom.apa.msgs.HDMap.name)
}
#endif
inline void HDMap::set_name(const char *value)
{
    GOOGLE_DCHECK(value != NULL);

    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                     ::std::string(value));
    // @@protoc_insertion_point(field_set_char:raincom.apa.msgs.HDMap.name)
}
inline void HDMap::set_name(const char *value, size_t size)
{

    name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                     ::std::string(reinterpret_cast<const char *>(value), size));
    // @@protoc_insertion_point(field_set_pointer:raincom.apa.msgs.HDMap.name)
}
inline ::std::string *HDMap::mutable_name()
{

    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.HDMap.name)
    return name_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *HDMap::release_name()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.HDMap.name)

    return name_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDMap::set_allocated_name(::std::string *name)
{
    if (name != NULL)
    {
    }
    else
    {
    }
    name_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.HDMap.name)
}

// .raincom.apa.msgs.Pose start = 4;
inline bool HDMap::has_start() const
{
    return this != internal_default_instance() && start_ != NULL;
}
inline const ::raincom::apa::msgs::Pose &HDMap::_internal_start() const
{
    return *start_;
}
inline const ::raincom::apa::msgs::Pose &HDMap::start() const
{
    const ::raincom::apa::msgs::Pose *p = start_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.HDMap.start)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Pose *>(
                           &::raincom::apa::msgs::_Pose_default_instance_);
}
inline ::raincom::apa::msgs::Pose *HDMap::release_start()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.HDMap.start)

    ::raincom::apa::msgs::Pose *temp = start_;
    start_                           = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Pose *HDMap::mutable_start()
{

    if (start_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Pose>(GetArenaNoVirtual());
        start_  = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.HDMap.start)
    return start_;
}
inline void HDMap::set_allocated_start(::raincom::apa::msgs::Pose *start)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(start_);
    }
    if (start)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            start = ::google::protobuf::internal::GetOwnedMessage(message_arena, start,
                                                                  submessage_arena);
        }
    }
    else
    {
    }
    start_ = start;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.HDMap.start)
}

// .raincom.apa.msgs.Pose slot = 5;
inline bool HDMap::has_slot() const
{
    return this != internal_default_instance() && slot_ != NULL;
}
inline const ::raincom::apa::msgs::Pose &HDMap::_internal_slot() const { return *slot_; }
inline const ::raincom::apa::msgs::Pose &HDMap::slot() const
{
    const ::raincom::apa::msgs::Pose *p = slot_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.HDMap.slot)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Pose *>(
                           &::raincom::apa::msgs::_Pose_default_instance_);
}
inline ::raincom::apa::msgs::Pose *HDMap::release_slot()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.HDMap.slot)

    ::raincom::apa::msgs::Pose *temp = slot_;
    slot_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Pose *HDMap::mutable_slot()
{

    if (slot_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Pose>(GetArenaNoVirtual());
        slot_   = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.HDMap.slot)
    return slot_;
}
inline void HDMap::set_allocated_slot(::raincom::apa::msgs::Pose *slot)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(slot_);
    }
    if (slot)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            slot = ::google::protobuf::internal::GetOwnedMessage(message_arena, slot,
                                                                 submessage_arena);
        }
    }
    else
    {
    }
    slot_ = slot;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.HDMap.slot)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2fhd_5fmap_2eproto
