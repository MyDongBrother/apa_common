// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/localization.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2flocalization_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2flocalization_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "apa_msgs/common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2flocalization_2eproto

namespace protobuf_apa_5fmsgs_2flocalization_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[2];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2flocalization_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class Odom;
class OdomDefaultTypeInternal;
extern OdomDefaultTypeInternal _Odom_default_instance_;
class Odom3d;
class Odom3dDefaultTypeInternal;
extern Odom3dDefaultTypeInternal _Odom3d_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::Odom *Arena::CreateMaybeMessage<::raincom::apa::msgs::Odom>(
    Arena *);
template <>
::raincom::apa::msgs::Odom3d *Arena::CreateMaybeMessage<::raincom::apa::msgs::Odom3d>(
    Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

// ===================================================================

class Odom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Odom)
                                                 */
{
  public:
    Odom();
    virtual ~Odom();

    Odom(const Odom &from);

    inline Odom &operator=(const Odom &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Odom(Odom &&from) noexcept : Odom() { *this = ::std::move(from); }

    inline Odom &operator=(Odom &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Odom &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Odom *internal_default_instance()
    {
        return reinterpret_cast<const Odom *>(&_Odom_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(Odom *other);
    friend void swap(Odom &a, Odom &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Odom *New() const final { return CreateMaybeMessage<Odom>(NULL); }

    Odom *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Odom>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Odom &from);
    void MergeFrom(const Odom &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Odom *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // float x = 2;
    void clear_x();
    static const int kXFieldNumber = 2;
    float x() const;
    void set_x(float value);

    // float y = 3;
    void clear_y();
    static const int kYFieldNumber = 3;
    float y() const;
    void set_y(float value);

    // float heading = 4;
    void clear_heading();
    static const int kHeadingFieldNumber = 4;
    float heading() const;
    void set_heading(float value);

    // float s = 5;
    void clear_s();
    static const int kSFieldNumber = 5;
    float s() const;
    void set_s(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Odom)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Header *header_;
    float x_;
    float y_;
    float heading_;
    float s_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Odom3d)
                                                   */
{
  public:
    Odom3d();
    virtual ~Odom3d();

    Odom3d(const Odom3d &from);

    inline Odom3d &operator=(const Odom3d &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Odom3d(Odom3d &&from) noexcept : Odom3d() { *this = ::std::move(from); }

    inline Odom3d &operator=(Odom3d &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Odom3d &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Odom3d *internal_default_instance()
    {
        return reinterpret_cast<const Odom3d *>(&_Odom3d_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    void Swap(Odom3d *other);
    friend void swap(Odom3d &a, Odom3d &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Odom3d *New() const final { return CreateMaybeMessage<Odom3d>(NULL); }

    Odom3d *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Odom3d>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Odom3d &from);
    void MergeFrom(const Odom3d &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Odom3d *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // .raincom.apa.msgs.Vec3 transform = 2;
    bool has_transform() const;
    void clear_transform();
    static const int kTransformFieldNumber = 2;

  private:
    const ::raincom::apa::msgs::Vec3 &_internal_transform() const;

  public:
    const ::raincom::apa::msgs::Vec3 &transform() const;
    ::raincom::apa::msgs::Vec3 *release_transform();
    ::raincom::apa::msgs::Vec3 *mutable_transform();
    void set_allocated_transform(::raincom::apa::msgs::Vec3 *transform);

    // .raincom.apa.msgs.EulerAngle rotation = 3;
    bool has_rotation() const;
    void clear_rotation();
    static const int kRotationFieldNumber = 3;

  private:
    const ::raincom::apa::msgs::EulerAngle &_internal_rotation() const;

  public:
    const ::raincom::apa::msgs::EulerAngle &rotation() const;
    ::raincom::apa::msgs::EulerAngle *release_rotation();
    ::raincom::apa::msgs::EulerAngle *mutable_rotation();
    void set_allocated_rotation(::raincom::apa::msgs::EulerAngle *rotation);

    // .raincom.apa.msgs.Twist twist = 4;
    bool has_twist() const;
    void clear_twist();
    static const int kTwistFieldNumber = 4;

  private:
    const ::raincom::apa::msgs::Twist &_internal_twist() const;

  public:
    const ::raincom::apa::msgs::Twist &twist() const;
    ::raincom::apa::msgs::Twist *release_twist();
    ::raincom::apa::msgs::Twist *mutable_twist();
    void set_allocated_twist(::raincom::apa::msgs::Twist *twist);

    // float confidence = 5;
    void clear_confidence();
    static const int kConfidenceFieldNumber = 5;
    float confidence() const;
    void set_confidence(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Odom3d)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Header *header_;
    ::raincom::apa::msgs::Vec3 *transform_;
    ::raincom::apa::msgs::EulerAngle *rotation_;
    ::raincom::apa::msgs::Twist *twist_;
    float confidence_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2flocalization_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Odom

// .raincom.apa.msgs.Header header = 1;
inline bool Odom::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &Odom::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &Odom::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *Odom::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Odom.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *Odom::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Odom.header)
    return header_;
}
inline void Odom::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Odom.header)
}

// float x = 2;
inline void Odom::clear_x() { x_ = 0; }
inline float Odom::x() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom.x)
    return x_;
}
inline void Odom::set_x(float value)
{

    x_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Odom.x)
}

// float y = 3;
inline void Odom::clear_y() { y_ = 0; }
inline float Odom::y() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom.y)
    return y_;
}
inline void Odom::set_y(float value)
{

    y_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Odom.y)
}

// float heading = 4;
inline void Odom::clear_heading() { heading_ = 0; }
inline float Odom::heading() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom.heading)
    return heading_;
}
inline void Odom::set_heading(float value)
{

    heading_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Odom.heading)
}

// float s = 5;
inline void Odom::clear_s() { s_ = 0; }
inline float Odom::s() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom.s)
    return s_;
}
inline void Odom::set_s(float value)
{

    s_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Odom.s)
}

// -------------------------------------------------------------------

// Odom3d

// .raincom.apa.msgs.Header header = 1;
inline bool Odom3d::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &Odom3d::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &Odom3d::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom3d.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *Odom3d::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Odom3d.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *Odom3d::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Odom3d.header)
    return header_;
}
inline void Odom3d::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Odom3d.header)
}

// .raincom.apa.msgs.Vec3 transform = 2;
inline bool Odom3d::has_transform() const
{
    return this != internal_default_instance() && transform_ != NULL;
}
inline const ::raincom::apa::msgs::Vec3 &Odom3d::_internal_transform() const
{
    return *transform_;
}
inline const ::raincom::apa::msgs::Vec3 &Odom3d::transform() const
{
    const ::raincom::apa::msgs::Vec3 *p = transform_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom3d.transform)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec3 *>(
                           &::raincom::apa::msgs::_Vec3_default_instance_);
}
inline ::raincom::apa::msgs::Vec3 *Odom3d::release_transform()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Odom3d.transform)

    ::raincom::apa::msgs::Vec3 *temp = transform_;
    transform_                       = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec3 *Odom3d::mutable_transform()
{

    if (transform_ == NULL)
    {
        auto *p    = CreateMaybeMessage<::raincom::apa::msgs::Vec3>(GetArenaNoVirtual());
        transform_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Odom3d.transform)
    return transform_;
}
inline void Odom3d::set_allocated_transform(::raincom::apa::msgs::Vec3 *transform)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(transform_);
    }
    if (transform)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            transform = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, transform, submessage_arena);
        }
    }
    else
    {
    }
    transform_ = transform;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Odom3d.transform)
}

// .raincom.apa.msgs.EulerAngle rotation = 3;
inline bool Odom3d::has_rotation() const
{
    return this != internal_default_instance() && rotation_ != NULL;
}
inline const ::raincom::apa::msgs::EulerAngle &Odom3d::_internal_rotation() const
{
    return *rotation_;
}
inline const ::raincom::apa::msgs::EulerAngle &Odom3d::rotation() const
{
    const ::raincom::apa::msgs::EulerAngle *p = rotation_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom3d.rotation)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::EulerAngle *>(
                           &::raincom::apa::msgs::_EulerAngle_default_instance_);
}
inline ::raincom::apa::msgs::EulerAngle *Odom3d::release_rotation()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Odom3d.rotation)

    ::raincom::apa::msgs::EulerAngle *temp = rotation_;
    rotation_                              = NULL;
    return temp;
}
inline ::raincom::apa::msgs::EulerAngle *Odom3d::mutable_rotation()
{

    if (rotation_ == NULL)
    {
        auto *p =
            CreateMaybeMessage<::raincom::apa::msgs::EulerAngle>(GetArenaNoVirtual());
        rotation_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Odom3d.rotation)
    return rotation_;
}
inline void Odom3d::set_allocated_rotation(::raincom::apa::msgs::EulerAngle *rotation)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(rotation_);
    }
    if (rotation)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            rotation = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, rotation, submessage_arena);
        }
    }
    else
    {
    }
    rotation_ = rotation;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Odom3d.rotation)
}

// .raincom.apa.msgs.Twist twist = 4;
inline bool Odom3d::has_twist() const
{
    return this != internal_default_instance() && twist_ != NULL;
}
inline const ::raincom::apa::msgs::Twist &Odom3d::_internal_twist() const
{
    return *twist_;
}
inline const ::raincom::apa::msgs::Twist &Odom3d::twist() const
{
    const ::raincom::apa::msgs::Twist *p = twist_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom3d.twist)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Twist *>(
                           &::raincom::apa::msgs::_Twist_default_instance_);
}
inline ::raincom::apa::msgs::Twist *Odom3d::release_twist()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Odom3d.twist)

    ::raincom::apa::msgs::Twist *temp = twist_;
    twist_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Twist *Odom3d::mutable_twist()
{

    if (twist_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Twist>(GetArenaNoVirtual());
        twist_  = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Odom3d.twist)
    return twist_;
}
inline void Odom3d::set_allocated_twist(::raincom::apa::msgs::Twist *twist)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(twist_);
    }
    if (twist)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            twist = ::google::protobuf::internal::GetOwnedMessage(message_arena, twist,
                                                                  submessage_arena);
        }
    }
    else
    {
    }
    twist_ = twist;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Odom3d.twist)
}

// float confidence = 5;
inline void Odom3d::clear_confidence() { confidence_ = 0; }
inline float Odom3d::confidence() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Odom3d.confidence)
    return confidence_;
}
inline void Odom3d::set_confidence(float value)
{

    confidence_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Odom3d.confidence)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2flocalization_2eproto
