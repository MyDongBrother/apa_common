// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/common.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2fcommon_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2fcommon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2fcommon_2eproto

namespace protobuf_apa_5fmsgs_2fcommon_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[8];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2fcommon_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class EulerAngle;
class EulerAngleDefaultTypeInternal;
extern EulerAngleDefaultTypeInternal _EulerAngle_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class OBB2d;
class OBB2dDefaultTypeInternal;
extern OBB2dDefaultTypeInternal _OBB2d_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Twist;
class TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class Vec2;
class Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec3;
class Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::EulerAngle *Arena::CreateMaybeMessage<
    ::raincom::apa::msgs::EulerAngle>(Arena *);
template <>
::raincom::apa::msgs::Header *Arena::CreateMaybeMessage<::raincom::apa::msgs::Header>(
    Arena *);
template <>
::raincom::apa::msgs::OBB2d *Arena::CreateMaybeMessage<::raincom::apa::msgs::OBB2d>(
    Arena *);
template <>
::raincom::apa::msgs::Pose *Arena::CreateMaybeMessage<::raincom::apa::msgs::Pose>(
    Arena *);
template <>
::raincom::apa::msgs::Quaternion *Arena::CreateMaybeMessage<
    ::raincom::apa::msgs::Quaternion>(Arena *);
template <>
::raincom::apa::msgs::Twist *Arena::CreateMaybeMessage<::raincom::apa::msgs::Twist>(
    Arena *);
template <>
::raincom::apa::msgs::Vec2 *Arena::CreateMaybeMessage<::raincom::apa::msgs::Vec2>(
    Arena *);
template <>
::raincom::apa::msgs::Vec3 *Arena::CreateMaybeMessage<::raincom::apa::msgs::Vec3>(
    Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Header)
                                                   */
{
  public:
    Header();
    virtual ~Header();

    Header(const Header &from);

    inline Header &operator=(const Header &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Header(Header &&from) noexcept : Header() { *this = ::std::move(from); }

    inline Header &operator=(Header &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Header &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Header *internal_default_instance()
    {
        return reinterpret_cast<const Header *>(&_Header_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(Header *other);
    friend void swap(Header &a, Header &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Header *New() const final { return CreateMaybeMessage<Header>(NULL); }

    Header *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Header>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Header &from);
    void MergeFrom(const Header &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Header *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // uint32 stamp = 1;
    void clear_stamp();
    static const int kStampFieldNumber = 1;
    ::google::protobuf::uint32 stamp() const;
    void set_stamp(::google::protobuf::uint32 value);

    // int32 id = 2;
    void clear_id();
    static const int kIdFieldNumber = 2;
    ::google::protobuf::int32 id() const;
    void set_id(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Header)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::uint32 stamp_;
    ::google::protobuf::int32 id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vec2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Vec2)
                                                 */
{
  public:
    Vec2();
    virtual ~Vec2();

    Vec2(const Vec2 &from);

    inline Vec2 &operator=(const Vec2 &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Vec2(Vec2 &&from) noexcept : Vec2() { *this = ::std::move(from); }

    inline Vec2 &operator=(Vec2 &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Vec2 &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Vec2 *internal_default_instance()
    {
        return reinterpret_cast<const Vec2 *>(&_Vec2_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    void Swap(Vec2 *other);
    friend void swap(Vec2 &a, Vec2 &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Vec2 *New() const final { return CreateMaybeMessage<Vec2>(NULL); }

    Vec2 *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Vec2>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Vec2 &from);
    void MergeFrom(const Vec2 &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Vec2 *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // float x = 1;
    void clear_x();
    static const int kXFieldNumber = 1;
    float x() const;
    void set_x(float value);

    // float y = 2;
    void clear_y();
    static const int kYFieldNumber = 2;
    float y() const;
    void set_y(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Vec2)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vec3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Vec3)
                                                 */
{
  public:
    Vec3();
    virtual ~Vec3();

    Vec3(const Vec3 &from);

    inline Vec3 &operator=(const Vec3 &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Vec3(Vec3 &&from) noexcept : Vec3() { *this = ::std::move(from); }

    inline Vec3 &operator=(Vec3 &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Vec3 &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Vec3 *internal_default_instance()
    {
        return reinterpret_cast<const Vec3 *>(&_Vec3_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    void Swap(Vec3 *other);
    friend void swap(Vec3 &a, Vec3 &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Vec3 *New() const final { return CreateMaybeMessage<Vec3>(NULL); }

    Vec3 *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Vec3>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Vec3 &from);
    void MergeFrom(const Vec3 &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Vec3 *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // float x = 1;
    void clear_x();
    static const int kXFieldNumber = 1;
    float x() const;
    void set_x(float value);

    // float y = 2;
    void clear_y();
    static const int kYFieldNumber = 2;
    float y() const;
    void set_y(float value);

    // float z = 3;
    void clear_z();
    static const int kZFieldNumber = 3;
    float z() const;
    void set_z(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Vec3)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Quaternion)
                                                       */
{
  public:
    Quaternion();
    virtual ~Quaternion();

    Quaternion(const Quaternion &from);

    inline Quaternion &operator=(const Quaternion &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Quaternion(Quaternion &&from) noexcept : Quaternion() { *this = ::std::move(from); }

    inline Quaternion &operator=(Quaternion &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Quaternion &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Quaternion *internal_default_instance()
    {
        return reinterpret_cast<const Quaternion *>(&_Quaternion_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    void Swap(Quaternion *other);
    friend void swap(Quaternion &a, Quaternion &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Quaternion *New() const final { return CreateMaybeMessage<Quaternion>(NULL); }

    Quaternion *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Quaternion>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Quaternion &from);
    void MergeFrom(const Quaternion &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Quaternion *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // float x = 1;
    void clear_x();
    static const int kXFieldNumber = 1;
    float x() const;
    void set_x(float value);

    // float y = 2;
    void clear_y();
    static const int kYFieldNumber = 2;
    float y() const;
    void set_y(float value);

    // float z = 3;
    void clear_z();
    static const int kZFieldNumber = 3;
    float z() const;
    void set_z(float value);

    // float w = 4;
    void clear_w();
    static const int kWFieldNumber = 4;
    float w() const;
    void set_w(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Quaternion)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    float x_;
    float y_;
    float z_;
    float w_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EulerAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.EulerAngle)
                                                       */
{
  public:
    EulerAngle();
    virtual ~EulerAngle();

    EulerAngle(const EulerAngle &from);

    inline EulerAngle &operator=(const EulerAngle &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    EulerAngle(EulerAngle &&from) noexcept : EulerAngle() { *this = ::std::move(from); }

    inline EulerAngle &operator=(EulerAngle &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const EulerAngle &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const EulerAngle *internal_default_instance()
    {
        return reinterpret_cast<const EulerAngle *>(&_EulerAngle_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    void Swap(EulerAngle *other);
    friend void swap(EulerAngle &a, EulerAngle &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline EulerAngle *New() const final { return CreateMaybeMessage<EulerAngle>(NULL); }

    EulerAngle *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<EulerAngle>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const EulerAngle &from);
    void MergeFrom(const EulerAngle &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(EulerAngle *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // float r = 1;
    void clear_r();
    static const int kRFieldNumber = 1;
    float r() const;
    void set_r(float value);

    // float p = 2;
    void clear_p();
    static const int kPFieldNumber = 2;
    float p() const;
    void set_p(float value);

    // float y = 3;
    void clear_y();
    static const int kYFieldNumber = 3;
    float y() const;
    void set_y(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.EulerAngle)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    float r_;
    float p_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Pose)
                                                 */
{
  public:
    Pose();
    virtual ~Pose();

    Pose(const Pose &from);

    inline Pose &operator=(const Pose &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Pose(Pose &&from) noexcept : Pose() { *this = ::std::move(from); }

    inline Pose &operator=(Pose &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Pose &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Pose *internal_default_instance()
    {
        return reinterpret_cast<const Pose *>(&_Pose_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    void Swap(Pose *other);
    friend void swap(Pose &a, Pose &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Pose *New() const final { return CreateMaybeMessage<Pose>(NULL); }

    Pose *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Pose>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Pose &from);
    void MergeFrom(const Pose &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Pose *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Vec3 position = 1;
    bool has_position() const;
    void clear_position();
    static const int kPositionFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Vec3 &_internal_position() const;

  public:
    const ::raincom::apa::msgs::Vec3 &position() const;
    ::raincom::apa::msgs::Vec3 *release_position();
    ::raincom::apa::msgs::Vec3 *mutable_position();
    void set_allocated_position(::raincom::apa::msgs::Vec3 *position);

    // .raincom.apa.msgs.EulerAngle rotation = 2;
    bool has_rotation() const;
    void clear_rotation();
    static const int kRotationFieldNumber = 2;

  private:
    const ::raincom::apa::msgs::EulerAngle &_internal_rotation() const;

  public:
    const ::raincom::apa::msgs::EulerAngle &rotation() const;
    ::raincom::apa::msgs::EulerAngle *release_rotation();
    ::raincom::apa::msgs::EulerAngle *mutable_rotation();
    void set_allocated_rotation(::raincom::apa::msgs::EulerAngle *rotation);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Pose)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Vec3 *position_;
    ::raincom::apa::msgs::EulerAngle *rotation_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Twist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Twist)
                                                  */
{
  public:
    Twist();
    virtual ~Twist();

    Twist(const Twist &from);

    inline Twist &operator=(const Twist &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Twist(Twist &&from) noexcept : Twist() { *this = ::std::move(from); }

    inline Twist &operator=(Twist &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Twist &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Twist *internal_default_instance()
    {
        return reinterpret_cast<const Twist *>(&_Twist_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    void Swap(Twist *other);
    friend void swap(Twist &a, Twist &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Twist *New() const final { return CreateMaybeMessage<Twist>(NULL); }

    Twist *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Twist>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Twist &from);
    void MergeFrom(const Twist &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Twist *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Vec3 linear = 1;
    bool has_linear() const;
    void clear_linear();
    static const int kLinearFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Vec3 &_internal_linear() const;

  public:
    const ::raincom::apa::msgs::Vec3 &linear() const;
    ::raincom::apa::msgs::Vec3 *release_linear();
    ::raincom::apa::msgs::Vec3 *mutable_linear();
    void set_allocated_linear(::raincom::apa::msgs::Vec3 *linear);

    // .raincom.apa.msgs.EulerAngle angular = 2;
    bool has_angular() const;
    void clear_angular();
    static const int kAngularFieldNumber = 2;

  private:
    const ::raincom::apa::msgs::EulerAngle &_internal_angular() const;

  public:
    const ::raincom::apa::msgs::EulerAngle &angular() const;
    ::raincom::apa::msgs::EulerAngle *release_angular();
    ::raincom::apa::msgs::EulerAngle *mutable_angular();
    void set_allocated_angular(::raincom::apa::msgs::EulerAngle *angular);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Twist)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Vec3 *linear_;
    ::raincom::apa::msgs::EulerAngle *angular_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OBB2d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.OBB2d)
                                                  */
{
  public:
    OBB2d();
    virtual ~OBB2d();

    OBB2d(const OBB2d &from);

    inline OBB2d &operator=(const OBB2d &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    OBB2d(OBB2d &&from) noexcept : OBB2d() { *this = ::std::move(from); }

    inline OBB2d &operator=(OBB2d &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const OBB2d &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const OBB2d *internal_default_instance()
    {
        return reinterpret_cast<const OBB2d *>(&_OBB2d_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    void Swap(OBB2d *other);
    friend void swap(OBB2d &a, OBB2d &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline OBB2d *New() const final { return CreateMaybeMessage<OBB2d>(NULL); }

    OBB2d *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<OBB2d>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const OBB2d &from);
    void MergeFrom(const OBB2d &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(OBB2d *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Vec2 center = 1;
    bool has_center() const;
    void clear_center();
    static const int kCenterFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Vec2 &_internal_center() const;

  public:
    const ::raincom::apa::msgs::Vec2 &center() const;
    ::raincom::apa::msgs::Vec2 *release_center();
    ::raincom::apa::msgs::Vec2 *mutable_center();
    void set_allocated_center(::raincom::apa::msgs::Vec2 *center);

    // .raincom.apa.msgs.Vec2 shape = 2;
    bool has_shape() const;
    void clear_shape();
    static const int kShapeFieldNumber = 2;

  private:
    const ::raincom::apa::msgs::Vec2 &_internal_shape() const;

  public:
    const ::raincom::apa::msgs::Vec2 &shape() const;
    ::raincom::apa::msgs::Vec2 *release_shape();
    ::raincom::apa::msgs::Vec2 *mutable_shape();
    void set_allocated_shape(::raincom::apa::msgs::Vec2 *shape);

    // .raincom.apa.msgs.Vec2 center_var = 4;
    bool has_center_var() const;
    void clear_center_var();
    static const int kCenterVarFieldNumber = 4;

  private:
    const ::raincom::apa::msgs::Vec2 &_internal_center_var() const;

  public:
    const ::raincom::apa::msgs::Vec2 &center_var() const;
    ::raincom::apa::msgs::Vec2 *release_center_var();
    ::raincom::apa::msgs::Vec2 *mutable_center_var();
    void set_allocated_center_var(::raincom::apa::msgs::Vec2 *center_var);

    // .raincom.apa.msgs.Vec2 shape_var = 5;
    bool has_shape_var() const;
    void clear_shape_var();
    static const int kShapeVarFieldNumber = 5;

  private:
    const ::raincom::apa::msgs::Vec2 &_internal_shape_var() const;

  public:
    const ::raincom::apa::msgs::Vec2 &shape_var() const;
    ::raincom::apa::msgs::Vec2 *release_shape_var();
    ::raincom::apa::msgs::Vec2 *mutable_shape_var();
    void set_allocated_shape_var(::raincom::apa::msgs::Vec2 *shape_var);

    // float heading = 3;
    void clear_heading();
    static const int kHeadingFieldNumber = 3;
    float heading() const;
    void set_heading(float value);

    // float heading_var = 6;
    void clear_heading_var();
    static const int kHeadingVarFieldNumber = 6;
    float heading_var() const;
    void set_heading_var(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.OBB2d)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Vec2 *center_;
    ::raincom::apa::msgs::Vec2 *shape_;
    ::raincom::apa::msgs::Vec2 *center_var_;
    ::raincom::apa::msgs::Vec2 *shape_var_;
    float heading_;
    float heading_var_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fcommon_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Header

// uint32 stamp = 1;
inline void Header::clear_stamp() { stamp_ = 0u; }
inline ::google::protobuf::uint32 Header::stamp() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Header.stamp)
    return stamp_;
}
inline void Header::set_stamp(::google::protobuf::uint32 value)
{

    stamp_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Header.stamp)
}

// int32 id = 2;
inline void Header::clear_id() { id_ = 0; }
inline ::google::protobuf::int32 Header::id() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Header.id)
    return id_;
}
inline void Header::set_id(::google::protobuf::int32 value)
{

    id_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Header.id)
}

// -------------------------------------------------------------------

// Vec2

// float x = 1;
inline void Vec2::clear_x() { x_ = 0; }
inline float Vec2::x() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Vec2.x)
    return x_;
}
inline void Vec2::set_x(float value)
{

    x_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Vec2.x)
}

// float y = 2;
inline void Vec2::clear_y() { y_ = 0; }
inline float Vec2::y() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Vec2.y)
    return y_;
}
inline void Vec2::set_y(float value)
{

    y_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Vec2.y)
}

// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() { x_ = 0; }
inline float Vec3::x() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Vec3.x)
    return x_;
}
inline void Vec3::set_x(float value)
{

    x_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Vec3.x)
}

// float y = 2;
inline void Vec3::clear_y() { y_ = 0; }
inline float Vec3::y() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Vec3.y)
    return y_;
}
inline void Vec3::set_y(float value)
{

    y_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Vec3.y)
}

// float z = 3;
inline void Vec3::clear_z() { z_ = 0; }
inline float Vec3::z() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Vec3.z)
    return z_;
}
inline void Vec3::set_z(float value)
{

    z_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Vec3.z)
}

// -------------------------------------------------------------------

// Quaternion

// float x = 1;
inline void Quaternion::clear_x() { x_ = 0; }
inline float Quaternion::x() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Quaternion.x)
    return x_;
}
inline void Quaternion::set_x(float value)
{

    x_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Quaternion.x)
}

// float y = 2;
inline void Quaternion::clear_y() { y_ = 0; }
inline float Quaternion::y() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Quaternion.y)
    return y_;
}
inline void Quaternion::set_y(float value)
{

    y_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Quaternion.y)
}

// float z = 3;
inline void Quaternion::clear_z() { z_ = 0; }
inline float Quaternion::z() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Quaternion.z)
    return z_;
}
inline void Quaternion::set_z(float value)
{

    z_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Quaternion.z)
}

// float w = 4;
inline void Quaternion::clear_w() { w_ = 0; }
inline float Quaternion::w() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Quaternion.w)
    return w_;
}
inline void Quaternion::set_w(float value)
{

    w_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Quaternion.w)
}

// -------------------------------------------------------------------

// EulerAngle

// float r = 1;
inline void EulerAngle::clear_r() { r_ = 0; }
inline float EulerAngle::r() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.EulerAngle.r)
    return r_;
}
inline void EulerAngle::set_r(float value)
{

    r_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.EulerAngle.r)
}

// float p = 2;
inline void EulerAngle::clear_p() { p_ = 0; }
inline float EulerAngle::p() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.EulerAngle.p)
    return p_;
}
inline void EulerAngle::set_p(float value)
{

    p_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.EulerAngle.p)
}

// float y = 3;
inline void EulerAngle::clear_y() { y_ = 0; }
inline float EulerAngle::y() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.EulerAngle.y)
    return y_;
}
inline void EulerAngle::set_y(float value)
{

    y_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.EulerAngle.y)
}

// -------------------------------------------------------------------

// Pose

// .raincom.apa.msgs.Vec3 position = 1;
inline bool Pose::has_position() const
{
    return this != internal_default_instance() && position_ != NULL;
}
inline void Pose::clear_position()
{
    if (GetArenaNoVirtual() == NULL && position_ != NULL)
    {
        delete position_;
    }
    position_ = NULL;
}
inline const ::raincom::apa::msgs::Vec3 &Pose::_internal_position() const
{
    return *position_;
}
inline const ::raincom::apa::msgs::Vec3 &Pose::position() const
{
    const ::raincom::apa::msgs::Vec3 *p = position_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Pose.position)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec3 *>(
                           &::raincom::apa::msgs::_Vec3_default_instance_);
}
inline ::raincom::apa::msgs::Vec3 *Pose::release_position()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Pose.position)

    ::raincom::apa::msgs::Vec3 *temp = position_;
    position_                        = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec3 *Pose::mutable_position()
{

    if (position_ == NULL)
    {
        auto *p   = CreateMaybeMessage<::raincom::apa::msgs::Vec3>(GetArenaNoVirtual());
        position_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Pose.position)
    return position_;
}
inline void Pose::set_allocated_position(::raincom::apa::msgs::Vec3 *position)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete position_;
    }
    if (position)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            position = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, position, submessage_arena);
        }
    }
    else
    {
    }
    position_ = position;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Pose.position)
}

// .raincom.apa.msgs.EulerAngle rotation = 2;
inline bool Pose::has_rotation() const
{
    return this != internal_default_instance() && rotation_ != NULL;
}
inline void Pose::clear_rotation()
{
    if (GetArenaNoVirtual() == NULL && rotation_ != NULL)
    {
        delete rotation_;
    }
    rotation_ = NULL;
}
inline const ::raincom::apa::msgs::EulerAngle &Pose::_internal_rotation() const
{
    return *rotation_;
}
inline const ::raincom::apa::msgs::EulerAngle &Pose::rotation() const
{
    const ::raincom::apa::msgs::EulerAngle *p = rotation_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Pose.rotation)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::EulerAngle *>(
                           &::raincom::apa::msgs::_EulerAngle_default_instance_);
}
inline ::raincom::apa::msgs::EulerAngle *Pose::release_rotation()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Pose.rotation)

    ::raincom::apa::msgs::EulerAngle *temp = rotation_;
    rotation_                              = NULL;
    return temp;
}
inline ::raincom::apa::msgs::EulerAngle *Pose::mutable_rotation()
{

    if (rotation_ == NULL)
    {
        auto *p =
            CreateMaybeMessage<::raincom::apa::msgs::EulerAngle>(GetArenaNoVirtual());
        rotation_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Pose.rotation)
    return rotation_;
}
inline void Pose::set_allocated_rotation(::raincom::apa::msgs::EulerAngle *rotation)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete rotation_;
    }
    if (rotation)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            rotation = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, rotation, submessage_arena);
        }
    }
    else
    {
    }
    rotation_ = rotation;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Pose.rotation)
}

// -------------------------------------------------------------------

// Twist

// .raincom.apa.msgs.Vec3 linear = 1;
inline bool Twist::has_linear() const
{
    return this != internal_default_instance() && linear_ != NULL;
}
inline void Twist::clear_linear()
{
    if (GetArenaNoVirtual() == NULL && linear_ != NULL)
    {
        delete linear_;
    }
    linear_ = NULL;
}
inline const ::raincom::apa::msgs::Vec3 &Twist::_internal_linear() const
{
    return *linear_;
}
inline const ::raincom::apa::msgs::Vec3 &Twist::linear() const
{
    const ::raincom::apa::msgs::Vec3 *p = linear_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Twist.linear)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec3 *>(
                           &::raincom::apa::msgs::_Vec3_default_instance_);
}
inline ::raincom::apa::msgs::Vec3 *Twist::release_linear()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Twist.linear)

    ::raincom::apa::msgs::Vec3 *temp = linear_;
    linear_                          = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec3 *Twist::mutable_linear()
{

    if (linear_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Vec3>(GetArenaNoVirtual());
        linear_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Twist.linear)
    return linear_;
}
inline void Twist::set_allocated_linear(::raincom::apa::msgs::Vec3 *linear)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete linear_;
    }
    if (linear)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            linear = ::google::protobuf::internal::GetOwnedMessage(message_arena, linear,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    linear_ = linear;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Twist.linear)
}

// .raincom.apa.msgs.EulerAngle angular = 2;
inline bool Twist::has_angular() const
{
    return this != internal_default_instance() && angular_ != NULL;
}
inline void Twist::clear_angular()
{
    if (GetArenaNoVirtual() == NULL && angular_ != NULL)
    {
        delete angular_;
    }
    angular_ = NULL;
}
inline const ::raincom::apa::msgs::EulerAngle &Twist::_internal_angular() const
{
    return *angular_;
}
inline const ::raincom::apa::msgs::EulerAngle &Twist::angular() const
{
    const ::raincom::apa::msgs::EulerAngle *p = angular_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Twist.angular)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::EulerAngle *>(
                           &::raincom::apa::msgs::_EulerAngle_default_instance_);
}
inline ::raincom::apa::msgs::EulerAngle *Twist::release_angular()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Twist.angular)

    ::raincom::apa::msgs::EulerAngle *temp = angular_;
    angular_                               = NULL;
    return temp;
}
inline ::raincom::apa::msgs::EulerAngle *Twist::mutable_angular()
{

    if (angular_ == NULL)
    {
        auto *p =
            CreateMaybeMessage<::raincom::apa::msgs::EulerAngle>(GetArenaNoVirtual());
        angular_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Twist.angular)
    return angular_;
}
inline void Twist::set_allocated_angular(::raincom::apa::msgs::EulerAngle *angular)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete angular_;
    }
    if (angular)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            angular = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, angular, submessage_arena);
        }
    }
    else
    {
    }
    angular_ = angular;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Twist.angular)
}

// -------------------------------------------------------------------

// OBB2d

// .raincom.apa.msgs.Vec2 center = 1;
inline bool OBB2d::has_center() const
{
    return this != internal_default_instance() && center_ != NULL;
}
inline void OBB2d::clear_center()
{
    if (GetArenaNoVirtual() == NULL && center_ != NULL)
    {
        delete center_;
    }
    center_ = NULL;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::_internal_center() const
{
    return *center_;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::center() const
{
    const ::raincom::apa::msgs::Vec2 *p = center_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.OBB2d.center)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec2 *>(
                           &::raincom::apa::msgs::_Vec2_default_instance_);
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::release_center()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.OBB2d.center)

    ::raincom::apa::msgs::Vec2 *temp = center_;
    center_                          = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::mutable_center()
{

    if (center_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Vec2>(GetArenaNoVirtual());
        center_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.OBB2d.center)
    return center_;
}
inline void OBB2d::set_allocated_center(::raincom::apa::msgs::Vec2 *center)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete center_;
    }
    if (center)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            center = ::google::protobuf::internal::GetOwnedMessage(message_arena, center,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    center_ = center;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.OBB2d.center)
}

// .raincom.apa.msgs.Vec2 shape = 2;
inline bool OBB2d::has_shape() const
{
    return this != internal_default_instance() && shape_ != NULL;
}
inline void OBB2d::clear_shape()
{
    if (GetArenaNoVirtual() == NULL && shape_ != NULL)
    {
        delete shape_;
    }
    shape_ = NULL;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::_internal_shape() const
{
    return *shape_;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::shape() const
{
    const ::raincom::apa::msgs::Vec2 *p = shape_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.OBB2d.shape)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec2 *>(
                           &::raincom::apa::msgs::_Vec2_default_instance_);
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::release_shape()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.OBB2d.shape)

    ::raincom::apa::msgs::Vec2 *temp = shape_;
    shape_                           = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::mutable_shape()
{

    if (shape_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Vec2>(GetArenaNoVirtual());
        shape_  = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.OBB2d.shape)
    return shape_;
}
inline void OBB2d::set_allocated_shape(::raincom::apa::msgs::Vec2 *shape)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete shape_;
    }
    if (shape)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            shape = ::google::protobuf::internal::GetOwnedMessage(message_arena, shape,
                                                                  submessage_arena);
        }
    }
    else
    {
    }
    shape_ = shape;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.OBB2d.shape)
}

// float heading = 3;
inline void OBB2d::clear_heading() { heading_ = 0; }
inline float OBB2d::heading() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.OBB2d.heading)
    return heading_;
}
inline void OBB2d::set_heading(float value)
{

    heading_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.OBB2d.heading)
}

// .raincom.apa.msgs.Vec2 center_var = 4;
inline bool OBB2d::has_center_var() const
{
    return this != internal_default_instance() && center_var_ != NULL;
}
inline void OBB2d::clear_center_var()
{
    if (GetArenaNoVirtual() == NULL && center_var_ != NULL)
    {
        delete center_var_;
    }
    center_var_ = NULL;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::_internal_center_var() const
{
    return *center_var_;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::center_var() const
{
    const ::raincom::apa::msgs::Vec2 *p = center_var_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.OBB2d.center_var)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec2 *>(
                           &::raincom::apa::msgs::_Vec2_default_instance_);
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::release_center_var()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.OBB2d.center_var)

    ::raincom::apa::msgs::Vec2 *temp = center_var_;
    center_var_                      = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::mutable_center_var()
{

    if (center_var_ == NULL)
    {
        auto *p     = CreateMaybeMessage<::raincom::apa::msgs::Vec2>(GetArenaNoVirtual());
        center_var_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.OBB2d.center_var)
    return center_var_;
}
inline void OBB2d::set_allocated_center_var(::raincom::apa::msgs::Vec2 *center_var)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete center_var_;
    }
    if (center_var)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            center_var = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, center_var, submessage_arena);
        }
    }
    else
    {
    }
    center_var_ = center_var;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.OBB2d.center_var)
}

// .raincom.apa.msgs.Vec2 shape_var = 5;
inline bool OBB2d::has_shape_var() const
{
    return this != internal_default_instance() && shape_var_ != NULL;
}
inline void OBB2d::clear_shape_var()
{
    if (GetArenaNoVirtual() == NULL && shape_var_ != NULL)
    {
        delete shape_var_;
    }
    shape_var_ = NULL;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::_internal_shape_var() const
{
    return *shape_var_;
}
inline const ::raincom::apa::msgs::Vec2 &OBB2d::shape_var() const
{
    const ::raincom::apa::msgs::Vec2 *p = shape_var_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.OBB2d.shape_var)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Vec2 *>(
                           &::raincom::apa::msgs::_Vec2_default_instance_);
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::release_shape_var()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.OBB2d.shape_var)

    ::raincom::apa::msgs::Vec2 *temp = shape_var_;
    shape_var_                       = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Vec2 *OBB2d::mutable_shape_var()
{

    if (shape_var_ == NULL)
    {
        auto *p    = CreateMaybeMessage<::raincom::apa::msgs::Vec2>(GetArenaNoVirtual());
        shape_var_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.OBB2d.shape_var)
    return shape_var_;
}
inline void OBB2d::set_allocated_shape_var(::raincom::apa::msgs::Vec2 *shape_var)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete shape_var_;
    }
    if (shape_var)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            shape_var = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, shape_var, submessage_arena);
        }
    }
    else
    {
    }
    shape_var_ = shape_var;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.OBB2d.shape_var)
}

// float heading_var = 6;
inline void OBB2d::clear_heading_var() { heading_var_ = 0; }
inline float OBB2d::heading_var() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.OBB2d.heading_var)
    return heading_var_;
}
inline void OBB2d::set_heading_var(float value)
{

    heading_var_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.OBB2d.heading_var)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2fcommon_2eproto
