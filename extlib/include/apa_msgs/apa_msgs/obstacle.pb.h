// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/obstacle.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2fobstacle_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2fobstacle_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "apa_msgs/common.pb.h"
#include "apa_msgs/objects.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2fobstacle_2eproto

namespace protobuf_apa_5fmsgs_2fobstacle_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[2];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2fobstacle_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class ObstacleFrame;
class ObstacleFrameDefaultTypeInternal;
extern ObstacleFrameDefaultTypeInternal _ObstacleFrame_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::Obstacle *Arena::CreateMaybeMessage<::raincom::apa::msgs::Obstacle>(
    Arena *);
template <>
::raincom::apa::msgs::ObstacleFrame *Arena::CreateMaybeMessage<
    ::raincom::apa::msgs::ObstacleFrame>(Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

enum Obstacle_Sensor
{
    Obstacle_Sensor_UNKNOWN_SENSOR = 0,
    Obstacle_Sensor_FRONT          = 1,
    Obstacle_Sensor_RIGHT          = 2,
    Obstacle_Sensor_BACK           = 3,
    Obstacle_Sensor_LEFT           = 4,
    Obstacle_Sensor_BEV            = 5,
    Obstacle_Sensor_LR             = 6,
    Obstacle_Sensor_FB             = 7,
    Obstacle_Sensor_Obstacle_Sensor_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    Obstacle_Sensor_Obstacle_Sensor_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool Obstacle_Sensor_IsValid(int value);
const Obstacle_Sensor Obstacle_Sensor_Sensor_MIN = Obstacle_Sensor_UNKNOWN_SENSOR;
const Obstacle_Sensor Obstacle_Sensor_Sensor_MAX = Obstacle_Sensor_FB;
const int Obstacle_Sensor_Sensor_ARRAYSIZE       = Obstacle_Sensor_Sensor_MAX + 1;

const ::google::protobuf::EnumDescriptor *Obstacle_Sensor_descriptor();
inline const ::std::string &Obstacle_Sensor_Name(Obstacle_Sensor value)
{
    return ::google::protobuf::internal::NameOfEnum(Obstacle_Sensor_descriptor(), value);
}
inline bool Obstacle_Sensor_Parse(const ::std::string &name, Obstacle_Sensor *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<Obstacle_Sensor>(
        Obstacle_Sensor_descriptor(), name, value);
}
// ===================================================================

class Obstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Obstacle)
                                                     */
{
  public:
    Obstacle();
    virtual ~Obstacle();

    Obstacle(const Obstacle &from);

    inline Obstacle &operator=(const Obstacle &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Obstacle(Obstacle &&from) noexcept : Obstacle() { *this = ::std::move(from); }

    inline Obstacle &operator=(Obstacle &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Obstacle &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Obstacle *internal_default_instance()
    {
        return reinterpret_cast<const Obstacle *>(&_Obstacle_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(Obstacle *other);
    friend void swap(Obstacle &a, Obstacle &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Obstacle *New() const final { return CreateMaybeMessage<Obstacle>(NULL); }

    Obstacle *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Obstacle>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Obstacle &from);
    void MergeFrom(const Obstacle &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Obstacle *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    typedef Obstacle_Sensor Sensor;
    static const Sensor UNKNOWN_SENSOR = Obstacle_Sensor_UNKNOWN_SENSOR;
    static const Sensor FRONT          = Obstacle_Sensor_FRONT;
    static const Sensor RIGHT          = Obstacle_Sensor_RIGHT;
    static const Sensor BACK           = Obstacle_Sensor_BACK;
    static const Sensor LEFT           = Obstacle_Sensor_LEFT;
    static const Sensor BEV            = Obstacle_Sensor_BEV;
    static const Sensor LR             = Obstacle_Sensor_LR;
    static const Sensor FB             = Obstacle_Sensor_FB;
    static inline bool Sensor_IsValid(int value)
    {
        return Obstacle_Sensor_IsValid(value);
    }
    static const Sensor Sensor_MIN    = Obstacle_Sensor_Sensor_MIN;
    static const Sensor Sensor_MAX    = Obstacle_Sensor_Sensor_MAX;
    static const int Sensor_ARRAYSIZE = Obstacle_Sensor_Sensor_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *Sensor_descriptor()
    {
        return Obstacle_Sensor_descriptor();
    }
    static inline const ::std::string &Sensor_Name(Sensor value)
    {
        return Obstacle_Sensor_Name(value);
    }
    static inline bool Sensor_Parse(const ::std::string &name, Sensor *value)
    {
        return Obstacle_Sensor_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // repeated .raincom.apa.msgs.Vec2 corners = 11;
    int corners_size() const;
    void clear_corners();
    static const int kCornersFieldNumber = 11;
    ::raincom::apa::msgs::Vec2 *mutable_corners(int index);
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> *mutable_corners();
    const ::raincom::apa::msgs::Vec2 &corners(int index) const;
    ::raincom::apa::msgs::Vec2 *add_corners();
    const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> &corners()
        const;

    // repeated .raincom.apa.msgs.Vec2 valid_corners = 14;
    int valid_corners_size() const;
    void clear_valid_corners();
    static const int kValidCornersFieldNumber = 14;
    ::raincom::apa::msgs::Vec2 *mutable_valid_corners(int index);
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
        *mutable_valid_corners();
    const ::raincom::apa::msgs::Vec2 &valid_corners(int index) const;
    ::raincom::apa::msgs::Vec2 *add_valid_corners();
    const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
        &valid_corners() const;

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // .raincom.apa.msgs.OBB2d obb = 6;
    bool has_obb() const;
    void clear_obb();
    static const int kObbFieldNumber = 6;

  private:
    const ::raincom::apa::msgs::OBB2d &_internal_obb() const;

  public:
    const ::raincom::apa::msgs::OBB2d &obb() const;
    ::raincom::apa::msgs::OBB2d *release_obb();
    ::raincom::apa::msgs::OBB2d *mutable_obb();
    void set_allocated_obb(::raincom::apa::msgs::OBB2d *obb);

    // float conf = 2;
    void clear_conf();
    static const int kConfFieldNumber = 2;
    float conf() const;
    void set_conf(float value);

    // int32 age = 3;
    void clear_age();
    static const int kAgeFieldNumber = 3;
    ::google::protobuf::int32 age() const;
    void set_age(::google::protobuf::int32 value);

    // .raincom.apa.msgs.Obstacle.Sensor sensor = 4;
    void clear_sensor();
    static const int kSensorFieldNumber = 4;
    ::raincom::apa::msgs::Obstacle_Sensor sensor() const;
    void set_sensor(::raincom::apa::msgs::Obstacle_Sensor value);

    // int32 ref_slot = 5;
    void clear_ref_slot();
    static const int kRefSlotFieldNumber = 5;
    ::google::protobuf::int32 ref_slot() const;
    void set_ref_slot(::google::protobuf::int32 value);

    // .raincom.apa.msgs.Object.Clf clf = 7;
    void clear_clf();
    static const int kClfFieldNumber = 7;
    ::raincom::apa::msgs::Object_Clf clf() const;
    void set_clf(::raincom::apa::msgs::Object_Clf value);

    // float clf_conf = 8;
    void clear_clf_conf();
    static const int kClfConfFieldNumber = 8;
    float clf_conf() const;
    void set_clf_conf(float value);

    // bool is_static = 13;
    void clear_is_static();
    static const int kIsStaticFieldNumber = 13;
    bool is_static() const;
    void set_is_static(bool value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Obstacle)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> corners_;
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> valid_corners_;
    ::raincom::apa::msgs::Header *header_;
    ::raincom::apa::msgs::OBB2d *obb_;
    float conf_;
    ::google::protobuf::int32 age_;
    int sensor_;
    ::google::protobuf::int32 ref_slot_;
    int clf_;
    float clf_conf_;
    bool is_static_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fobstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.ObstacleFrame)
                                                          */
{
  public:
    ObstacleFrame();
    virtual ~ObstacleFrame();

    ObstacleFrame(const ObstacleFrame &from);

    inline ObstacleFrame &operator=(const ObstacleFrame &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    ObstacleFrame(ObstacleFrame &&from) noexcept : ObstacleFrame()
    {
        *this = ::std::move(from);
    }

    inline ObstacleFrame &operator=(ObstacleFrame &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const ObstacleFrame &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const ObstacleFrame *internal_default_instance()
    {
        return reinterpret_cast<const ObstacleFrame *>(&_ObstacleFrame_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    void Swap(ObstacleFrame *other);
    friend void swap(ObstacleFrame &a, ObstacleFrame &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline ObstacleFrame *New() const final
    {
        return CreateMaybeMessage<ObstacleFrame>(NULL);
    }

    ObstacleFrame *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<ObstacleFrame>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const ObstacleFrame &from);
    void MergeFrom(const ObstacleFrame &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(ObstacleFrame *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .raincom.apa.msgs.Obstacle obstacle_list = 2;
    int obstacle_list_size() const;
    void clear_obstacle_list();
    static const int kObstacleListFieldNumber = 2;
    ::raincom::apa::msgs::Obstacle *mutable_obstacle_list(int index);
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Obstacle>
        *mutable_obstacle_list();
    const ::raincom::apa::msgs::Obstacle &obstacle_list(int index) const;
    ::raincom::apa::msgs::Obstacle *add_obstacle_list();
    const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Obstacle>
        &obstacle_list() const;

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.ObstacleFrame)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Obstacle> obstacle_list_;
    ::raincom::apa::msgs::Header *header_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fobstacle_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Obstacle

// .raincom.apa.msgs.Header header = 1;
inline bool Obstacle::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &Obstacle::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &Obstacle::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *Obstacle::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Obstacle.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *Obstacle::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Obstacle.header)
    return header_;
}
inline void Obstacle::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Obstacle.header)
}

// float conf = 2;
inline void Obstacle::clear_conf() { conf_ = 0; }
inline float Obstacle::conf() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.conf)
    return conf_;
}
inline void Obstacle::set_conf(float value)
{

    conf_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.conf)
}

// int32 age = 3;
inline void Obstacle::clear_age() { age_ = 0; }
inline ::google::protobuf::int32 Obstacle::age() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.age)
    return age_;
}
inline void Obstacle::set_age(::google::protobuf::int32 value)
{

    age_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.age)
}

// .raincom.apa.msgs.Obstacle.Sensor sensor = 4;
inline void Obstacle::clear_sensor() { sensor_ = 0; }
inline ::raincom::apa::msgs::Obstacle_Sensor Obstacle::sensor() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.sensor)
    return static_cast<::raincom::apa::msgs::Obstacle_Sensor>(sensor_);
}
inline void Obstacle::set_sensor(::raincom::apa::msgs::Obstacle_Sensor value)
{

    sensor_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.sensor)
}

// int32 ref_slot = 5;
inline void Obstacle::clear_ref_slot() { ref_slot_ = 0; }
inline ::google::protobuf::int32 Obstacle::ref_slot() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.ref_slot)
    return ref_slot_;
}
inline void Obstacle::set_ref_slot(::google::protobuf::int32 value)
{

    ref_slot_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.ref_slot)
}

// .raincom.apa.msgs.OBB2d obb = 6;
inline bool Obstacle::has_obb() const
{
    return this != internal_default_instance() && obb_ != NULL;
}
inline const ::raincom::apa::msgs::OBB2d &Obstacle::_internal_obb() const
{
    return *obb_;
}
inline const ::raincom::apa::msgs::OBB2d &Obstacle::obb() const
{
    const ::raincom::apa::msgs::OBB2d *p = obb_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.obb)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::OBB2d *>(
                           &::raincom::apa::msgs::_OBB2d_default_instance_);
}
inline ::raincom::apa::msgs::OBB2d *Obstacle::release_obb()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Obstacle.obb)

    ::raincom::apa::msgs::OBB2d *temp = obb_;
    obb_                              = NULL;
    return temp;
}
inline ::raincom::apa::msgs::OBB2d *Obstacle::mutable_obb()
{

    if (obb_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::OBB2d>(GetArenaNoVirtual());
        obb_    = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Obstacle.obb)
    return obb_;
}
inline void Obstacle::set_allocated_obb(::raincom::apa::msgs::OBB2d *obb)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(obb_);
    }
    if (obb)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            obb = ::google::protobuf::internal::GetOwnedMessage(message_arena, obb,
                                                                submessage_arena);
        }
    }
    else
    {
    }
    obb_ = obb;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Obstacle.obb)
}

// .raincom.apa.msgs.Object.Clf clf = 7;
inline void Obstacle::clear_clf() { clf_ = 0; }
inline ::raincom::apa::msgs::Object_Clf Obstacle::clf() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.clf)
    return static_cast<::raincom::apa::msgs::Object_Clf>(clf_);
}
inline void Obstacle::set_clf(::raincom::apa::msgs::Object_Clf value)
{

    clf_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.clf)
}

// float clf_conf = 8;
inline void Obstacle::clear_clf_conf() { clf_conf_ = 0; }
inline float Obstacle::clf_conf() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.clf_conf)
    return clf_conf_;
}
inline void Obstacle::set_clf_conf(float value)
{

    clf_conf_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.clf_conf)
}

// repeated .raincom.apa.msgs.Vec2 corners = 11;
inline int Obstacle::corners_size() const { return corners_.size(); }
inline ::raincom::apa::msgs::Vec2 *Obstacle::mutable_corners(int index)
{
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Obstacle.corners)
    return corners_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
    *Obstacle::mutable_corners()
{
    // @@protoc_insertion_point(field_mutable_list:raincom.apa.msgs.Obstacle.corners)
    return &corners_;
}
inline const ::raincom::apa::msgs::Vec2 &Obstacle::corners(int index) const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.corners)
    return corners_.Get(index);
}
inline ::raincom::apa::msgs::Vec2 *Obstacle::add_corners()
{
    // @@protoc_insertion_point(field_add:raincom.apa.msgs.Obstacle.corners)
    return corners_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
    &Obstacle::corners() const
{
    // @@protoc_insertion_point(field_list:raincom.apa.msgs.Obstacle.corners)
    return corners_;
}

// bool is_static = 13;
inline void Obstacle::clear_is_static() { is_static_ = false; }
inline bool Obstacle::is_static() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.is_static)
    return is_static_;
}
inline void Obstacle::set_is_static(bool value)
{

    is_static_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Obstacle.is_static)
}

// repeated .raincom.apa.msgs.Vec2 valid_corners = 14;
inline int Obstacle::valid_corners_size() const { return valid_corners_.size(); }
inline ::raincom::apa::msgs::Vec2 *Obstacle::mutable_valid_corners(int index)
{
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Obstacle.valid_corners)
    return valid_corners_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
    *Obstacle::mutable_valid_corners()
{
    // @@protoc_insertion_point(field_mutable_list:raincom.apa.msgs.Obstacle.valid_corners)
    return &valid_corners_;
}
inline const ::raincom::apa::msgs::Vec2 &Obstacle::valid_corners(int index) const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Obstacle.valid_corners)
    return valid_corners_.Get(index);
}
inline ::raincom::apa::msgs::Vec2 *Obstacle::add_valid_corners()
{
    // @@protoc_insertion_point(field_add:raincom.apa.msgs.Obstacle.valid_corners)
    return valid_corners_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
    &Obstacle::valid_corners() const
{
    // @@protoc_insertion_point(field_list:raincom.apa.msgs.Obstacle.valid_corners)
    return valid_corners_;
}

// -------------------------------------------------------------------

// ObstacleFrame

// .raincom.apa.msgs.Header header = 1;
inline bool ObstacleFrame::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &ObstacleFrame::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &ObstacleFrame::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.ObstacleFrame.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *ObstacleFrame::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.ObstacleFrame.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *ObstacleFrame::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.ObstacleFrame.header)
    return header_;
}
inline void ObstacleFrame::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.ObstacleFrame.header)
}

// repeated .raincom.apa.msgs.Obstacle obstacle_list = 2;
inline int ObstacleFrame::obstacle_list_size() const { return obstacle_list_.size(); }
inline void ObstacleFrame::clear_obstacle_list() { obstacle_list_.Clear(); }
inline ::raincom::apa::msgs::Obstacle *ObstacleFrame::mutable_obstacle_list(int index)
{
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.ObstacleFrame.obstacle_list)
    return obstacle_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Obstacle>
    *ObstacleFrame::mutable_obstacle_list()
{
    // @@protoc_insertion_point(field_mutable_list:raincom.apa.msgs.ObstacleFrame.obstacle_list)
    return &obstacle_list_;
}
inline const ::raincom::apa::msgs::Obstacle &ObstacleFrame::obstacle_list(int index) const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.ObstacleFrame.obstacle_list)
    return obstacle_list_.Get(index);
}
inline ::raincom::apa::msgs::Obstacle *ObstacleFrame::add_obstacle_list()
{
    // @@protoc_insertion_point(field_add:raincom.apa.msgs.ObstacleFrame.obstacle_list)
    return obstacle_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Obstacle>
    &ObstacleFrame::obstacle_list() const
{
    // @@protoc_insertion_point(field_list:raincom.apa.msgs.ObstacleFrame.obstacle_list)
    return obstacle_list_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

namespace google
{
namespace protobuf
{

template <>
struct is_proto_enum<::raincom::apa::msgs::Obstacle_Sensor> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::raincom::apa::msgs::Obstacle_Sensor>()
{
    return ::raincom::apa::msgs::Obstacle_Sensor_descriptor();
}

} // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2fobstacle_2eproto
