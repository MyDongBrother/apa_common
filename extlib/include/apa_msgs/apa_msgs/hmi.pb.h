// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/hmi.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2fhmi_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2fhmi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "apa_msgs/common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2fhmi_2eproto

namespace protobuf_apa_5fmsgs_2fhmi_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[2];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2fhmi_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class AvpStatus;
class AvpStatusDefaultTypeInternal;
extern AvpStatusDefaultTypeInternal _AvpStatus_default_instance_;
class UserCmd;
class UserCmdDefaultTypeInternal;
extern UserCmdDefaultTypeInternal _UserCmd_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::AvpStatus *Arena::CreateMaybeMessage<
    ::raincom::apa::msgs::AvpStatus>(Arena *);
template <>
::raincom::apa::msgs::UserCmd *Arena::CreateMaybeMessage<::raincom::apa::msgs::UserCmd>(
    Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

enum UserCmd_CmdType
{
    UserCmd_CmdType_CMD_UNDEFINED      = 0,
    UserCmd_CmdType_CMD_MAPPING_START  = 1,
    UserCmd_CmdType_CMD_MAPPING_FINISH = 2,
    UserCmd_CmdType_CMD_MAPPING_GIVEUP = 3,
    UserCmd_CmdType_CMD_DRIVE_TO_SLOT  = 4,
    UserCmd_CmdType_CMD_DRIVE_TO_START = 5,
    UserCmd_CmdType_CMD_DRIVE_QUIT     = 6,
    UserCmd_CmdType_UserCmd_CmdType_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    UserCmd_CmdType_UserCmd_CmdType_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool UserCmd_CmdType_IsValid(int value);
const UserCmd_CmdType UserCmd_CmdType_CmdType_MIN = UserCmd_CmdType_CMD_UNDEFINED;
const UserCmd_CmdType UserCmd_CmdType_CmdType_MAX = UserCmd_CmdType_CMD_DRIVE_QUIT;
const int UserCmd_CmdType_CmdType_ARRAYSIZE       = UserCmd_CmdType_CmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor *UserCmd_CmdType_descriptor();
inline const ::std::string &UserCmd_CmdType_Name(UserCmd_CmdType value)
{
    return ::google::protobuf::internal::NameOfEnum(UserCmd_CmdType_descriptor(), value);
}
inline bool UserCmd_CmdType_Parse(const ::std::string &name, UserCmd_CmdType *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<UserCmd_CmdType>(
        UserCmd_CmdType_descriptor(), name, value);
}
enum AvpStatus_StatusType
{
    AvpStatus_StatusType_ST_UNDEFINED               = 0,
    AvpStatus_StatusType_ST_LOC_LOST                = 1,
    AvpStatus_StatusType_ST_LOC_LOW_CONF            = 2,
    AvpStatus_StatusType_ST_MAPPING_OK              = 3,
    AvpStatus_StatusType_ST_MAPPING_FAILED          = 4,
    AvpStatus_StatusType_ST_MAPPING_READY           = 5,
    AvpStatus_StatusType_ST_MAPPING_STARTING        = 6,
    AvpStatus_StatusType_ST_MAPPING_STARTED         = 7,
    AvpStatus_StatusType_ST_MAPPING_NOT_STARTED     = 8,
    AvpStatus_StatusType_ST_MAPPING_ALREADY_STARTED = 9,
    AvpStatus_StatusType_ST_MAPPING_WAIT_TO_FINISH  = 10,
    AvpStatus_StatusType_ST_MAPPING_FINISHED        = 11,
    AvpStatus_StatusType_ST_SLOT_PICKED             = 12,
    AvpStatus_StatusType_AvpStatus_StatusType_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    AvpStatus_StatusType_AvpStatus_StatusType_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool AvpStatus_StatusType_IsValid(int value);
const AvpStatus_StatusType AvpStatus_StatusType_StatusType_MIN =
    AvpStatus_StatusType_ST_UNDEFINED;
const AvpStatus_StatusType AvpStatus_StatusType_StatusType_MAX =
    AvpStatus_StatusType_ST_SLOT_PICKED;
const int AvpStatus_StatusType_StatusType_ARRAYSIZE =
    AvpStatus_StatusType_StatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor *AvpStatus_StatusType_descriptor();
inline const ::std::string &AvpStatus_StatusType_Name(AvpStatus_StatusType value)
{
    return ::google::protobuf::internal::NameOfEnum(AvpStatus_StatusType_descriptor(),
                                                    value);
}
inline bool AvpStatus_StatusType_Parse(const ::std::string &name,
                                       AvpStatus_StatusType *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<AvpStatus_StatusType>(
        AvpStatus_StatusType_descriptor(), name, value);
}
// ===================================================================

class UserCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.UserCmd)
                                                    */
{
  public:
    UserCmd();
    virtual ~UserCmd();

    UserCmd(const UserCmd &from);

    inline UserCmd &operator=(const UserCmd &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    UserCmd(UserCmd &&from) noexcept : UserCmd() { *this = ::std::move(from); }

    inline UserCmd &operator=(UserCmd &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const UserCmd &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const UserCmd *internal_default_instance()
    {
        return reinterpret_cast<const UserCmd *>(&_UserCmd_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(UserCmd *other);
    friend void swap(UserCmd &a, UserCmd &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline UserCmd *New() const final { return CreateMaybeMessage<UserCmd>(NULL); }

    UserCmd *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<UserCmd>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const UserCmd &from);
    void MergeFrom(const UserCmd &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(UserCmd *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    typedef UserCmd_CmdType CmdType;
    static const CmdType CMD_UNDEFINED      = UserCmd_CmdType_CMD_UNDEFINED;
    static const CmdType CMD_MAPPING_START  = UserCmd_CmdType_CMD_MAPPING_START;
    static const CmdType CMD_MAPPING_FINISH = UserCmd_CmdType_CMD_MAPPING_FINISH;
    static const CmdType CMD_MAPPING_GIVEUP = UserCmd_CmdType_CMD_MAPPING_GIVEUP;
    static const CmdType CMD_DRIVE_TO_SLOT  = UserCmd_CmdType_CMD_DRIVE_TO_SLOT;
    static const CmdType CMD_DRIVE_TO_START = UserCmd_CmdType_CMD_DRIVE_TO_START;
    static const CmdType CMD_DRIVE_QUIT     = UserCmd_CmdType_CMD_DRIVE_QUIT;
    static inline bool CmdType_IsValid(int value)
    {
        return UserCmd_CmdType_IsValid(value);
    }
    static const CmdType CmdType_MIN   = UserCmd_CmdType_CmdType_MIN;
    static const CmdType CmdType_MAX   = UserCmd_CmdType_CmdType_MAX;
    static const int CmdType_ARRAYSIZE = UserCmd_CmdType_CmdType_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *CmdType_descriptor()
    {
        return UserCmd_CmdType_descriptor();
    }
    static inline const ::std::string &CmdType_Name(CmdType value)
    {
        return UserCmd_CmdType_Name(value);
    }
    static inline bool CmdType_Parse(const ::std::string &name, CmdType *value)
    {
        return UserCmd_CmdType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // string map_name = 3;
    void clear_map_name();
    static const int kMapNameFieldNumber = 3;
    const ::std::string &map_name() const;
    void set_map_name(const ::std::string &value);
#if LANG_CXX11
    void set_map_name(::std::string &&value);
#endif
    void set_map_name(const char *value);
    void set_map_name(const char *value, size_t size);
    ::std::string *mutable_map_name();
    ::std::string *release_map_name();
    void set_allocated_map_name(::std::string *map_name);

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // .raincom.apa.msgs.UserCmd.CmdType cmd = 2;
    void clear_cmd();
    static const int kCmdFieldNumber = 2;
    ::raincom::apa::msgs::UserCmd_CmdType cmd() const;
    void set_cmd(::raincom::apa::msgs::UserCmd_CmdType value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.UserCmd)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::internal::ArenaStringPtr map_name_;
    ::raincom::apa::msgs::Header *header_;
    int cmd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fhmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AvpStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.AvpStatus)
                                                      */
{
  public:
    AvpStatus();
    virtual ~AvpStatus();

    AvpStatus(const AvpStatus &from);

    inline AvpStatus &operator=(const AvpStatus &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    AvpStatus(AvpStatus &&from) noexcept : AvpStatus() { *this = ::std::move(from); }

    inline AvpStatus &operator=(AvpStatus &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const AvpStatus &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const AvpStatus *internal_default_instance()
    {
        return reinterpret_cast<const AvpStatus *>(&_AvpStatus_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    void Swap(AvpStatus *other);
    friend void swap(AvpStatus &a, AvpStatus &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline AvpStatus *New() const final { return CreateMaybeMessage<AvpStatus>(NULL); }

    AvpStatus *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<AvpStatus>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const AvpStatus &from);
    void MergeFrom(const AvpStatus &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(AvpStatus *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    typedef AvpStatus_StatusType StatusType;
    static const StatusType ST_UNDEFINED      = AvpStatus_StatusType_ST_UNDEFINED;
    static const StatusType ST_LOC_LOST       = AvpStatus_StatusType_ST_LOC_LOST;
    static const StatusType ST_LOC_LOW_CONF   = AvpStatus_StatusType_ST_LOC_LOW_CONF;
    static const StatusType ST_MAPPING_OK     = AvpStatus_StatusType_ST_MAPPING_OK;
    static const StatusType ST_MAPPING_FAILED = AvpStatus_StatusType_ST_MAPPING_FAILED;
    static const StatusType ST_MAPPING_READY  = AvpStatus_StatusType_ST_MAPPING_READY;
    static const StatusType ST_MAPPING_STARTING =
        AvpStatus_StatusType_ST_MAPPING_STARTING;
    static const StatusType ST_MAPPING_STARTED = AvpStatus_StatusType_ST_MAPPING_STARTED;
    static const StatusType ST_MAPPING_NOT_STARTED =
        AvpStatus_StatusType_ST_MAPPING_NOT_STARTED;
    static const StatusType ST_MAPPING_ALREADY_STARTED =
        AvpStatus_StatusType_ST_MAPPING_ALREADY_STARTED;
    static const StatusType ST_MAPPING_WAIT_TO_FINISH =
        AvpStatus_StatusType_ST_MAPPING_WAIT_TO_FINISH;
    static const StatusType ST_MAPPING_FINISHED =
        AvpStatus_StatusType_ST_MAPPING_FINISHED;
    static const StatusType ST_SLOT_PICKED = AvpStatus_StatusType_ST_SLOT_PICKED;
    static inline bool StatusType_IsValid(int value)
    {
        return AvpStatus_StatusType_IsValid(value);
    }
    static const StatusType StatusType_MIN = AvpStatus_StatusType_StatusType_MIN;
    static const StatusType StatusType_MAX = AvpStatus_StatusType_StatusType_MAX;
    static const int StatusType_ARRAYSIZE  = AvpStatus_StatusType_StatusType_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *StatusType_descriptor()
    {
        return AvpStatus_StatusType_descriptor();
    }
    static inline const ::std::string &StatusType_Name(StatusType value)
    {
        return AvpStatus_StatusType_Name(value);
    }
    static inline bool StatusType_Parse(const ::std::string &name, StatusType *value)
    {
        return AvpStatus_StatusType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // .raincom.apa.msgs.AvpStatus.StatusType status = 2;
    void clear_status();
    static const int kStatusFieldNumber = 2;
    ::raincom::apa::msgs::AvpStatus_StatusType status() const;
    void set_status(::raincom::apa::msgs::AvpStatus_StatusType value);

    // int32 map_quality = 3;
    void clear_map_quality();
    static const int kMapQualityFieldNumber = 3;
    ::google::protobuf::int32 map_quality() const;
    void set_map_quality(::google::protobuf::int32 value);

    // float loc_conf = 4;
    void clear_loc_conf();
    static const int kLocConfFieldNumber = 4;
    float loc_conf() const;
    void set_loc_conf(float value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.AvpStatus)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Header *header_;
    int status_;
    ::google::protobuf::int32 map_quality_;
    float loc_conf_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fhmi_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// UserCmd

// .raincom.apa.msgs.Header header = 1;
inline bool UserCmd::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &UserCmd::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &UserCmd::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.UserCmd.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *UserCmd::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.UserCmd.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *UserCmd::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.UserCmd.header)
    return header_;
}
inline void UserCmd::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.UserCmd.header)
}

// .raincom.apa.msgs.UserCmd.CmdType cmd = 2;
inline void UserCmd::clear_cmd() { cmd_ = 0; }
inline ::raincom::apa::msgs::UserCmd_CmdType UserCmd::cmd() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.UserCmd.cmd)
    return static_cast<::raincom::apa::msgs::UserCmd_CmdType>(cmd_);
}
inline void UserCmd::set_cmd(::raincom::apa::msgs::UserCmd_CmdType value)
{

    cmd_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.UserCmd.cmd)
}

// string map_name = 3;
inline void UserCmd::clear_map_name()
{
    map_name_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &UserCmd::map_name() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.UserCmd.map_name)
    return map_name_.GetNoArena();
}
inline void UserCmd::set_map_name(const ::std::string &value)
{

    map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                         value);
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.UserCmd.map_name)
}
#if LANG_CXX11
inline void UserCmd::set_map_name(::std::string &&value)
{

    map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                         ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:raincom.apa.msgs.UserCmd.map_name)
}
#endif
inline void UserCmd::set_map_name(const char *value)
{
    GOOGLE_DCHECK(value != NULL);

    map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                         ::std::string(value));
    // @@protoc_insertion_point(field_set_char:raincom.apa.msgs.UserCmd.map_name)
}
inline void UserCmd::set_map_name(const char *value, size_t size)
{

    map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                         ::std::string(reinterpret_cast<const char *>(value), size));
    // @@protoc_insertion_point(field_set_pointer:raincom.apa.msgs.UserCmd.map_name)
}
inline ::std::string *UserCmd::mutable_map_name()
{

    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.UserCmd.map_name)
    return map_name_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *UserCmd::release_map_name()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.UserCmd.map_name)

    return map_name_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserCmd::set_allocated_map_name(::std::string *map_name)
{
    if (map_name != NULL)
    {
    }
    else
    {
    }
    map_name_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.UserCmd.map_name)
}

// -------------------------------------------------------------------

// AvpStatus

// .raincom.apa.msgs.Header header = 1;
inline bool AvpStatus::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &AvpStatus::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &AvpStatus::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.AvpStatus.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *AvpStatus::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.AvpStatus.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *AvpStatus::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.AvpStatus.header)
    return header_;
}
inline void AvpStatus::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.AvpStatus.header)
}

// .raincom.apa.msgs.AvpStatus.StatusType status = 2;
inline void AvpStatus::clear_status() { status_ = 0; }
inline ::raincom::apa::msgs::AvpStatus_StatusType AvpStatus::status() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.AvpStatus.status)
    return static_cast<::raincom::apa::msgs::AvpStatus_StatusType>(status_);
}
inline void AvpStatus::set_status(::raincom::apa::msgs::AvpStatus_StatusType value)
{

    status_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.AvpStatus.status)
}

// int32 map_quality = 3;
inline void AvpStatus::clear_map_quality() { map_quality_ = 0; }
inline ::google::protobuf::int32 AvpStatus::map_quality() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.AvpStatus.map_quality)
    return map_quality_;
}
inline void AvpStatus::set_map_quality(::google::protobuf::int32 value)
{

    map_quality_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.AvpStatus.map_quality)
}

// float loc_conf = 4;
inline void AvpStatus::clear_loc_conf() { loc_conf_ = 0; }
inline float AvpStatus::loc_conf() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.AvpStatus.loc_conf)
    return loc_conf_;
}
inline void AvpStatus::set_loc_conf(float value)
{

    loc_conf_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.AvpStatus.loc_conf)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

namespace google
{
namespace protobuf
{

template <>
struct is_proto_enum<::raincom::apa::msgs::UserCmd_CmdType> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::raincom::apa::msgs::UserCmd_CmdType>()
{
    return ::raincom::apa::msgs::UserCmd_CmdType_descriptor();
}
template <>
struct is_proto_enum<::raincom::apa::msgs::AvpStatus_StatusType> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<
    ::raincom::apa::msgs::AvpStatus_StatusType>()
{
    return ::raincom::apa::msgs::AvpStatus_StatusType_descriptor();
}

} // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2fhmi_2eproto
