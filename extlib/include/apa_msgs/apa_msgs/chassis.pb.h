// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/chassis.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2fchassis_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2fchassis_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "apa_msgs/common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2fchassis_2eproto

namespace protobuf_apa_5fmsgs_2fchassis_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[1];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2fchassis_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class Chassis;
class ChassisDefaultTypeInternal;
extern ChassisDefaultTypeInternal _Chassis_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::Chassis *Arena::CreateMaybeMessage<::raincom::apa::msgs::Chassis>(
    Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

enum Chassis_BeamStatus
{
    Chassis_BeamStatus_BEAM_INVALID  = 0,
    Chassis_BeamStatus_BEAM_LOW_ON   = 1,
    Chassis_BeamStatus_BEAM_HIGH_ON  = 2,
    Chassis_BeamStatus_BEAM_OFF      = 3,
    Chassis_BeamStatus_BEAM_RESERVED = 4,
    Chassis_BeamStatus_Chassis_BeamStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    Chassis_BeamStatus_Chassis_BeamStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool Chassis_BeamStatus_IsValid(int value);
const Chassis_BeamStatus Chassis_BeamStatus_BeamStatus_MIN =
    Chassis_BeamStatus_BEAM_INVALID;
const Chassis_BeamStatus Chassis_BeamStatus_BeamStatus_MAX =
    Chassis_BeamStatus_BEAM_RESERVED;
const int Chassis_BeamStatus_BeamStatus_ARRAYSIZE = Chassis_BeamStatus_BeamStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor *Chassis_BeamStatus_descriptor();
inline const ::std::string &Chassis_BeamStatus_Name(Chassis_BeamStatus value)
{
    return ::google::protobuf::internal::NameOfEnum(Chassis_BeamStatus_descriptor(),
                                                    value);
}
inline bool Chassis_BeamStatus_Parse(const ::std::string &name, Chassis_BeamStatus *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<Chassis_BeamStatus>(
        Chassis_BeamStatus_descriptor(), name, value);
}
enum Chassis_DoorStatus
{
    Chassis_DoorStatus_DOOR_INVALID = 0,
    Chassis_DoorStatus_DOOR_OPEND   = 1,
    Chassis_DoorStatus_DOOR_CLOSED  = 2,
    Chassis_DoorStatus_Chassis_DoorStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    Chassis_DoorStatus_Chassis_DoorStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool Chassis_DoorStatus_IsValid(int value);
const Chassis_DoorStatus Chassis_DoorStatus_DoorStatus_MIN =
    Chassis_DoorStatus_DOOR_INVALID;
const Chassis_DoorStatus Chassis_DoorStatus_DoorStatus_MAX =
    Chassis_DoorStatus_DOOR_CLOSED;
const int Chassis_DoorStatus_DoorStatus_ARRAYSIZE = Chassis_DoorStatus_DoorStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor *Chassis_DoorStatus_descriptor();
inline const ::std::string &Chassis_DoorStatus_Name(Chassis_DoorStatus value)
{
    return ::google::protobuf::internal::NameOfEnum(Chassis_DoorStatus_descriptor(),
                                                    value);
}
inline bool Chassis_DoorStatus_Parse(const ::std::string &name, Chassis_DoorStatus *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<Chassis_DoorStatus>(
        Chassis_DoorStatus_descriptor(), name, value);
}
// ===================================================================

class Chassis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Chassis)
                                                    */
{
  public:
    Chassis();
    virtual ~Chassis();

    Chassis(const Chassis &from);

    inline Chassis &operator=(const Chassis &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Chassis(Chassis &&from) noexcept : Chassis() { *this = ::std::move(from); }

    inline Chassis &operator=(Chassis &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Chassis &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Chassis *internal_default_instance()
    {
        return reinterpret_cast<const Chassis *>(&_Chassis_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(Chassis *other);
    friend void swap(Chassis &a, Chassis &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Chassis *New() const final { return CreateMaybeMessage<Chassis>(NULL); }

    Chassis *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Chassis>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Chassis &from);
    void MergeFrom(const Chassis &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Chassis *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    typedef Chassis_BeamStatus BeamStatus;
    static const BeamStatus BEAM_INVALID  = Chassis_BeamStatus_BEAM_INVALID;
    static const BeamStatus BEAM_LOW_ON   = Chassis_BeamStatus_BEAM_LOW_ON;
    static const BeamStatus BEAM_HIGH_ON  = Chassis_BeamStatus_BEAM_HIGH_ON;
    static const BeamStatus BEAM_OFF      = Chassis_BeamStatus_BEAM_OFF;
    static const BeamStatus BEAM_RESERVED = Chassis_BeamStatus_BEAM_RESERVED;
    static inline bool BeamStatus_IsValid(int value)
    {
        return Chassis_BeamStatus_IsValid(value);
    }
    static const BeamStatus BeamStatus_MIN = Chassis_BeamStatus_BeamStatus_MIN;
    static const BeamStatus BeamStatus_MAX = Chassis_BeamStatus_BeamStatus_MAX;
    static const int BeamStatus_ARRAYSIZE  = Chassis_BeamStatus_BeamStatus_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *BeamStatus_descriptor()
    {
        return Chassis_BeamStatus_descriptor();
    }
    static inline const ::std::string &BeamStatus_Name(BeamStatus value)
    {
        return Chassis_BeamStatus_Name(value);
    }
    static inline bool BeamStatus_Parse(const ::std::string &name, BeamStatus *value)
    {
        return Chassis_BeamStatus_Parse(name, value);
    }

    typedef Chassis_DoorStatus DoorStatus;
    static const DoorStatus DOOR_INVALID = Chassis_DoorStatus_DOOR_INVALID;
    static const DoorStatus DOOR_OPEND   = Chassis_DoorStatus_DOOR_OPEND;
    static const DoorStatus DOOR_CLOSED  = Chassis_DoorStatus_DOOR_CLOSED;
    static inline bool DoorStatus_IsValid(int value)
    {
        return Chassis_DoorStatus_IsValid(value);
    }
    static const DoorStatus DoorStatus_MIN = Chassis_DoorStatus_DoorStatus_MIN;
    static const DoorStatus DoorStatus_MAX = Chassis_DoorStatus_DoorStatus_MAX;
    static const int DoorStatus_ARRAYSIZE  = Chassis_DoorStatus_DoorStatus_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *DoorStatus_descriptor()
    {
        return Chassis_DoorStatus_descriptor();
    }
    static inline const ::std::string &DoorStatus_Name(DoorStatus value)
    {
        return Chassis_DoorStatus_Name(value);
    }
    static inline bool DoorStatus_Parse(const ::std::string &name, DoorStatus *value)
    {
        return Chassis_DoorStatus_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // float steering_wheel_angle = 3;
    void clear_steering_wheel_angle();
    static const int kSteeringWheelAngleFieldNumber = 3;
    float steering_wheel_angle() const;
    void set_steering_wheel_angle(float value);

    // float wheel_speed_fl = 5;
    void clear_wheel_speed_fl();
    static const int kWheelSpeedFlFieldNumber = 5;
    float wheel_speed_fl() const;
    void set_wheel_speed_fl(float value);

    // bool steering_wheel_angle_valid = 2;
    void clear_steering_wheel_angle_valid();
    static const int kSteeringWheelAngleValidFieldNumber = 2;
    bool steering_wheel_angle_valid() const;
    void set_steering_wheel_angle_valid(bool value);

    // bool wheel_speed_fl_valid = 4;
    void clear_wheel_speed_fl_valid();
    static const int kWheelSpeedFlValidFieldNumber = 4;
    bool wheel_speed_fl_valid() const;
    void set_wheel_speed_fl_valid(bool value);

    // bool wheel_speed_fr_valid = 6;
    void clear_wheel_speed_fr_valid();
    static const int kWheelSpeedFrValidFieldNumber = 6;
    bool wheel_speed_fr_valid() const;
    void set_wheel_speed_fr_valid(bool value);

    // bool wheel_speed_rl_valid = 8;
    void clear_wheel_speed_rl_valid();
    static const int kWheelSpeedRlValidFieldNumber = 8;
    bool wheel_speed_rl_valid() const;
    void set_wheel_speed_rl_valid(bool value);

    // float wheel_speed_fr = 7;
    void clear_wheel_speed_fr();
    static const int kWheelSpeedFrFieldNumber = 7;
    float wheel_speed_fr() const;
    void set_wheel_speed_fr(float value);

    // float wheel_speed_rl = 9;
    void clear_wheel_speed_rl();
    static const int kWheelSpeedRlFieldNumber = 9;
    float wheel_speed_rl() const;
    void set_wheel_speed_rl(float value);

    // bool wheel_speed_rr_valid = 10;
    void clear_wheel_speed_rr_valid();
    static const int kWheelSpeedRrValidFieldNumber = 10;
    bool wheel_speed_rr_valid() const;
    void set_wheel_speed_rr_valid(bool value);

    // float wheel_speed_rr = 11;
    void clear_wheel_speed_rr();
    static const int kWheelSpeedRrFieldNumber = 11;
    float wheel_speed_rr() const;
    void set_wheel_speed_rr(float value);

    // .raincom.apa.msgs.Chassis.BeamStatus beam = 12;
    void clear_beam();
    static const int kBeamFieldNumber = 12;
    ::raincom::apa::msgs::Chassis_BeamStatus beam() const;
    void set_beam(::raincom::apa::msgs::Chassis_BeamStatus value);

    // .raincom.apa.msgs.Chassis.DoorStatus rf_door = 13;
    void clear_rf_door();
    static const int kRfDoorFieldNumber = 13;
    ::raincom::apa::msgs::Chassis_DoorStatus rf_door() const;
    void set_rf_door(::raincom::apa::msgs::Chassis_DoorStatus value);

    // .raincom.apa.msgs.Chassis.DoorStatus lf_door = 14;
    void clear_lf_door();
    static const int kLfDoorFieldNumber = 14;
    ::raincom::apa::msgs::Chassis_DoorStatus lf_door() const;
    void set_lf_door(::raincom::apa::msgs::Chassis_DoorStatus value);

    // .raincom.apa.msgs.Chassis.DoorStatus rr_door = 15;
    void clear_rr_door();
    static const int kRrDoorFieldNumber = 15;
    ::raincom::apa::msgs::Chassis_DoorStatus rr_door() const;
    void set_rr_door(::raincom::apa::msgs::Chassis_DoorStatus value);

    // .raincom.apa.msgs.Chassis.DoorStatus lr_door = 16;
    void clear_lr_door();
    static const int kLrDoorFieldNumber = 16;
    ::raincom::apa::msgs::Chassis_DoorStatus lr_door() const;
    void set_lr_door(::raincom::apa::msgs::Chassis_DoorStatus value);

    // .raincom.apa.msgs.Chassis.DoorStatus front_hatch = 17;
    void clear_front_hatch();
    static const int kFrontHatchFieldNumber = 17;
    ::raincom::apa::msgs::Chassis_DoorStatus front_hatch() const;
    void set_front_hatch(::raincom::apa::msgs::Chassis_DoorStatus value);

    // .raincom.apa.msgs.Chassis.DoorStatus back_hatch = 18;
    void clear_back_hatch();
    static const int kBackHatchFieldNumber = 18;
    ::raincom::apa::msgs::Chassis_DoorStatus back_hatch() const;
    void set_back_hatch(::raincom::apa::msgs::Chassis_DoorStatus value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Chassis)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::raincom::apa::msgs::Header *header_;
    float steering_wheel_angle_;
    float wheel_speed_fl_;
    bool steering_wheel_angle_valid_;
    bool wheel_speed_fl_valid_;
    bool wheel_speed_fr_valid_;
    bool wheel_speed_rl_valid_;
    float wheel_speed_fr_;
    float wheel_speed_rl_;
    bool wheel_speed_rr_valid_;
    float wheel_speed_rr_;
    int beam_;
    int rf_door_;
    int lf_door_;
    int rr_door_;
    int lr_door_;
    int front_hatch_;
    int back_hatch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fchassis_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Chassis

// .raincom.apa.msgs.Header header = 1;
inline bool Chassis::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &Chassis::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &Chassis::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *Chassis::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Chassis.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *Chassis::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Chassis.header)
    return header_;
}
inline void Chassis::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Chassis.header)
}

// bool steering_wheel_angle_valid = 2;
inline void Chassis::clear_steering_wheel_angle_valid()
{
    steering_wheel_angle_valid_ = false;
}
inline bool Chassis::steering_wheel_angle_valid() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.steering_wheel_angle_valid)
    return steering_wheel_angle_valid_;
}
inline void Chassis::set_steering_wheel_angle_valid(bool value)
{

    steering_wheel_angle_valid_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.steering_wheel_angle_valid)
}

// float steering_wheel_angle = 3;
inline void Chassis::clear_steering_wheel_angle() { steering_wheel_angle_ = 0; }
inline float Chassis::steering_wheel_angle() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.steering_wheel_angle)
    return steering_wheel_angle_;
}
inline void Chassis::set_steering_wheel_angle(float value)
{

    steering_wheel_angle_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.steering_wheel_angle)
}

// bool wheel_speed_fl_valid = 4;
inline void Chassis::clear_wheel_speed_fl_valid() { wheel_speed_fl_valid_ = false; }
inline bool Chassis::wheel_speed_fl_valid() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_fl_valid)
    return wheel_speed_fl_valid_;
}
inline void Chassis::set_wheel_speed_fl_valid(bool value)
{

    wheel_speed_fl_valid_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_fl_valid)
}

// float wheel_speed_fl = 5;
inline void Chassis::clear_wheel_speed_fl() { wheel_speed_fl_ = 0; }
inline float Chassis::wheel_speed_fl() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_fl)
    return wheel_speed_fl_;
}
inline void Chassis::set_wheel_speed_fl(float value)
{

    wheel_speed_fl_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_fl)
}

// bool wheel_speed_fr_valid = 6;
inline void Chassis::clear_wheel_speed_fr_valid() { wheel_speed_fr_valid_ = false; }
inline bool Chassis::wheel_speed_fr_valid() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_fr_valid)
    return wheel_speed_fr_valid_;
}
inline void Chassis::set_wheel_speed_fr_valid(bool value)
{

    wheel_speed_fr_valid_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_fr_valid)
}

// float wheel_speed_fr = 7;
inline void Chassis::clear_wheel_speed_fr() { wheel_speed_fr_ = 0; }
inline float Chassis::wheel_speed_fr() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_fr)
    return wheel_speed_fr_;
}
inline void Chassis::set_wheel_speed_fr(float value)
{

    wheel_speed_fr_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_fr)
}

// bool wheel_speed_rl_valid = 8;
inline void Chassis::clear_wheel_speed_rl_valid() { wheel_speed_rl_valid_ = false; }
inline bool Chassis::wheel_speed_rl_valid() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_rl_valid)
    return wheel_speed_rl_valid_;
}
inline void Chassis::set_wheel_speed_rl_valid(bool value)
{

    wheel_speed_rl_valid_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_rl_valid)
}

// float wheel_speed_rl = 9;
inline void Chassis::clear_wheel_speed_rl() { wheel_speed_rl_ = 0; }
inline float Chassis::wheel_speed_rl() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_rl)
    return wheel_speed_rl_;
}
inline void Chassis::set_wheel_speed_rl(float value)
{

    wheel_speed_rl_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_rl)
}

// bool wheel_speed_rr_valid = 10;
inline void Chassis::clear_wheel_speed_rr_valid() { wheel_speed_rr_valid_ = false; }
inline bool Chassis::wheel_speed_rr_valid() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_rr_valid)
    return wheel_speed_rr_valid_;
}
inline void Chassis::set_wheel_speed_rr_valid(bool value)
{

    wheel_speed_rr_valid_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_rr_valid)
}

// float wheel_speed_rr = 11;
inline void Chassis::clear_wheel_speed_rr() { wheel_speed_rr_ = 0; }
inline float Chassis::wheel_speed_rr() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.wheel_speed_rr)
    return wheel_speed_rr_;
}
inline void Chassis::set_wheel_speed_rr(float value)
{

    wheel_speed_rr_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.wheel_speed_rr)
}

// .raincom.apa.msgs.Chassis.BeamStatus beam = 12;
inline void Chassis::clear_beam() { beam_ = 0; }
inline ::raincom::apa::msgs::Chassis_BeamStatus Chassis::beam() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.beam)
    return static_cast<::raincom::apa::msgs::Chassis_BeamStatus>(beam_);
}
inline void Chassis::set_beam(::raincom::apa::msgs::Chassis_BeamStatus value)
{

    beam_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.beam)
}

// .raincom.apa.msgs.Chassis.DoorStatus rf_door = 13;
inline void Chassis::clear_rf_door() { rf_door_ = 0; }
inline ::raincom::apa::msgs::Chassis_DoorStatus Chassis::rf_door() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.rf_door)
    return static_cast<::raincom::apa::msgs::Chassis_DoorStatus>(rf_door_);
}
inline void Chassis::set_rf_door(::raincom::apa::msgs::Chassis_DoorStatus value)
{

    rf_door_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.rf_door)
}

// .raincom.apa.msgs.Chassis.DoorStatus lf_door = 14;
inline void Chassis::clear_lf_door() { lf_door_ = 0; }
inline ::raincom::apa::msgs::Chassis_DoorStatus Chassis::lf_door() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.lf_door)
    return static_cast<::raincom::apa::msgs::Chassis_DoorStatus>(lf_door_);
}
inline void Chassis::set_lf_door(::raincom::apa::msgs::Chassis_DoorStatus value)
{

    lf_door_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.lf_door)
}

// .raincom.apa.msgs.Chassis.DoorStatus rr_door = 15;
inline void Chassis::clear_rr_door() { rr_door_ = 0; }
inline ::raincom::apa::msgs::Chassis_DoorStatus Chassis::rr_door() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.rr_door)
    return static_cast<::raincom::apa::msgs::Chassis_DoorStatus>(rr_door_);
}
inline void Chassis::set_rr_door(::raincom::apa::msgs::Chassis_DoorStatus value)
{

    rr_door_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.rr_door)
}

// .raincom.apa.msgs.Chassis.DoorStatus lr_door = 16;
inline void Chassis::clear_lr_door() { lr_door_ = 0; }
inline ::raincom::apa::msgs::Chassis_DoorStatus Chassis::lr_door() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.lr_door)
    return static_cast<::raincom::apa::msgs::Chassis_DoorStatus>(lr_door_);
}
inline void Chassis::set_lr_door(::raincom::apa::msgs::Chassis_DoorStatus value)
{

    lr_door_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.lr_door)
}

// .raincom.apa.msgs.Chassis.DoorStatus front_hatch = 17;
inline void Chassis::clear_front_hatch() { front_hatch_ = 0; }
inline ::raincom::apa::msgs::Chassis_DoorStatus Chassis::front_hatch() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.front_hatch)
    return static_cast<::raincom::apa::msgs::Chassis_DoorStatus>(front_hatch_);
}
inline void Chassis::set_front_hatch(::raincom::apa::msgs::Chassis_DoorStatus value)
{

    front_hatch_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.front_hatch)
}

// .raincom.apa.msgs.Chassis.DoorStatus back_hatch = 18;
inline void Chassis::clear_back_hatch() { back_hatch_ = 0; }
inline ::raincom::apa::msgs::Chassis_DoorStatus Chassis::back_hatch() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Chassis.back_hatch)
    return static_cast<::raincom::apa::msgs::Chassis_DoorStatus>(back_hatch_);
}
inline void Chassis::set_back_hatch(::raincom::apa::msgs::Chassis_DoorStatus value)
{

    back_hatch_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Chassis.back_hatch)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

namespace google
{
namespace protobuf
{

template <>
struct is_proto_enum<::raincom::apa::msgs::Chassis_BeamStatus> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::raincom::apa::msgs::Chassis_BeamStatus>()
{
    return ::raincom::apa::msgs::Chassis_BeamStatus_descriptor();
}
template <>
struct is_proto_enum<::raincom::apa::msgs::Chassis_DoorStatus> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::raincom::apa::msgs::Chassis_DoorStatus>()
{
    return ::raincom::apa::msgs::Chassis_DoorStatus_descriptor();
}

} // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2fchassis_2eproto
