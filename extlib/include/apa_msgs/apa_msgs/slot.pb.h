// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apa_msgs/slot.proto

#ifndef PROTOBUF_INCLUDED_apa_5fmsgs_2fslot_2eproto
#define PROTOBUF_INCLUDED_apa_5fmsgs_2fslot_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "apa_msgs/common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_apa_5fmsgs_2fslot_2eproto

namespace protobuf_apa_5fmsgs_2fslot_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct
{
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[2];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_apa_5fmsgs_2fslot_2eproto
namespace raincom
{
namespace apa
{
namespace msgs
{
class Slot;
class SlotDefaultTypeInternal;
extern SlotDefaultTypeInternal _Slot_default_instance_;
class SlotFrame;
class SlotFrameDefaultTypeInternal;
extern SlotFrameDefaultTypeInternal _SlotFrame_default_instance_;
} // namespace msgs
} // namespace apa
} // namespace raincom
namespace google
{
namespace protobuf
{
template <>
::raincom::apa::msgs::Slot *Arena::CreateMaybeMessage<::raincom::apa::msgs::Slot>(
    Arena *);
template <>
::raincom::apa::msgs::SlotFrame *Arena::CreateMaybeMessage<
    ::raincom::apa::msgs::SlotFrame>(Arena *);
} // namespace protobuf
} // namespace google
namespace raincom
{
namespace apa
{
namespace msgs
{

enum Slot_SlotType
{
    Slot_SlotType_UNKNOW_TYPE    = 0,
    Slot_SlotType_LEFT_PARALLEL  = 1,
    Slot_SlotType_RIGHT_PARALLEL = 2,
    Slot_SlotType_LEFT_VERTICAL  = 3,
    Slot_SlotType_RIGHT_VERTICAL = 4,
    Slot_SlotType_Slot_SlotType_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    Slot_SlotType_Slot_SlotType_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool Slot_SlotType_IsValid(int value);
const Slot_SlotType Slot_SlotType_SlotType_MIN = Slot_SlotType_UNKNOW_TYPE;
const Slot_SlotType Slot_SlotType_SlotType_MAX = Slot_SlotType_RIGHT_VERTICAL;
const int Slot_SlotType_SlotType_ARRAYSIZE     = Slot_SlotType_SlotType_MAX + 1;

const ::google::protobuf::EnumDescriptor *Slot_SlotType_descriptor();
inline const ::std::string &Slot_SlotType_Name(Slot_SlotType value)
{
    return ::google::protobuf::internal::NameOfEnum(Slot_SlotType_descriptor(), value);
}
inline bool Slot_SlotType_Parse(const ::std::string &name, Slot_SlotType *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<Slot_SlotType>(
        Slot_SlotType_descriptor(), name, value);
}
enum Slot_PLockStatus
{
    Slot_PLockStatus_PL_INVALID = 0,
    Slot_PLockStatus_PL_CLOSED  = 1,
    Slot_PLockStatus_PL_OPEND   = 2,
    Slot_PLockStatus_Slot_PLockStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32min,
    Slot_PLockStatus_Slot_PLockStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
        ::google::protobuf::kint32max
};
bool Slot_PLockStatus_IsValid(int value);
const Slot_PLockStatus Slot_PLockStatus_PLockStatus_MIN = Slot_PLockStatus_PL_INVALID;
const Slot_PLockStatus Slot_PLockStatus_PLockStatus_MAX = Slot_PLockStatus_PL_OPEND;
const int Slot_PLockStatus_PLockStatus_ARRAYSIZE = Slot_PLockStatus_PLockStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor *Slot_PLockStatus_descriptor();
inline const ::std::string &Slot_PLockStatus_Name(Slot_PLockStatus value)
{
    return ::google::protobuf::internal::NameOfEnum(Slot_PLockStatus_descriptor(), value);
}
inline bool Slot_PLockStatus_Parse(const ::std::string &name, Slot_PLockStatus *value)
{
    return ::google::protobuf::internal::ParseNamedEnum<Slot_PLockStatus>(
        Slot_PLockStatus_descriptor(), name, value);
}
// ===================================================================

class Slot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.Slot)
                                                 */
{
  public:
    Slot();
    virtual ~Slot();

    Slot(const Slot &from);

    inline Slot &operator=(const Slot &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Slot(Slot &&from) noexcept : Slot() { *this = ::std::move(from); }

    inline Slot &operator=(Slot &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const Slot &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Slot *internal_default_instance()
    {
        return reinterpret_cast<const Slot *>(&_Slot_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(Slot *other);
    friend void swap(Slot &a, Slot &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Slot *New() const final { return CreateMaybeMessage<Slot>(NULL); }

    Slot *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<Slot>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const Slot &from);
    void MergeFrom(const Slot &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(Slot *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    typedef Slot_SlotType SlotType;
    static const SlotType UNKNOW_TYPE    = Slot_SlotType_UNKNOW_TYPE;
    static const SlotType LEFT_PARALLEL  = Slot_SlotType_LEFT_PARALLEL;
    static const SlotType RIGHT_PARALLEL = Slot_SlotType_RIGHT_PARALLEL;
    static const SlotType LEFT_VERTICAL  = Slot_SlotType_LEFT_VERTICAL;
    static const SlotType RIGHT_VERTICAL = Slot_SlotType_RIGHT_VERTICAL;
    static inline bool SlotType_IsValid(int value)
    {
        return Slot_SlotType_IsValid(value);
    }
    static const SlotType SlotType_MIN  = Slot_SlotType_SlotType_MIN;
    static const SlotType SlotType_MAX  = Slot_SlotType_SlotType_MAX;
    static const int SlotType_ARRAYSIZE = Slot_SlotType_SlotType_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *SlotType_descriptor()
    {
        return Slot_SlotType_descriptor();
    }
    static inline const ::std::string &SlotType_Name(SlotType value)
    {
        return Slot_SlotType_Name(value);
    }
    static inline bool SlotType_Parse(const ::std::string &name, SlotType *value)
    {
        return Slot_SlotType_Parse(name, value);
    }

    typedef Slot_PLockStatus PLockStatus;
    static const PLockStatus PL_INVALID = Slot_PLockStatus_PL_INVALID;
    static const PLockStatus PL_CLOSED  = Slot_PLockStatus_PL_CLOSED;
    static const PLockStatus PL_OPEND   = Slot_PLockStatus_PL_OPEND;
    static inline bool PLockStatus_IsValid(int value)
    {
        return Slot_PLockStatus_IsValid(value);
    }
    static const PLockStatus PLockStatus_MIN = Slot_PLockStatus_PLockStatus_MIN;
    static const PLockStatus PLockStatus_MAX = Slot_PLockStatus_PLockStatus_MAX;
    static const int PLockStatus_ARRAYSIZE   = Slot_PLockStatus_PLockStatus_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor *PLockStatus_descriptor()
    {
        return Slot_PLockStatus_descriptor();
    }
    static inline const ::std::string &PLockStatus_Name(PLockStatus value)
    {
        return Slot_PLockStatus_Name(value);
    }
    static inline bool PLockStatus_Parse(const ::std::string &name, PLockStatus *value)
    {
        return Slot_PLockStatus_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // repeated .raincom.apa.msgs.Vec2 corners = 6;
    int corners_size() const;
    void clear_corners();
    static const int kCornersFieldNumber = 6;
    ::raincom::apa::msgs::Vec2 *mutable_corners(int index);
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> *mutable_corners();
    const ::raincom::apa::msgs::Vec2 &corners(int index) const;
    ::raincom::apa::msgs::Vec2 *add_corners();
    const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> &corners()
        const;

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // .raincom.apa.msgs.OBB2d obb = 5;
    bool has_obb() const;
    void clear_obb();
    static const int kObbFieldNumber = 5;

  private:
    const ::raincom::apa::msgs::OBB2d &_internal_obb() const;

  public:
    const ::raincom::apa::msgs::OBB2d &obb() const;
    ::raincom::apa::msgs::OBB2d *release_obb();
    ::raincom::apa::msgs::OBB2d *mutable_obb();
    void set_allocated_obb(::raincom::apa::msgs::OBB2d *obb);

    // .raincom.apa.msgs.Slot.SlotType type = 2;
    void clear_type();
    static const int kTypeFieldNumber = 2;
    ::raincom::apa::msgs::Slot_SlotType type() const;
    void set_type(::raincom::apa::msgs::Slot_SlotType value);

    // float conf = 3;
    void clear_conf();
    static const int kConfFieldNumber = 3;
    float conf() const;
    void set_conf(float value);

    // int32 age = 4;
    void clear_age();
    static const int kAgeFieldNumber = 4;
    ::google::protobuf::int32 age() const;
    void set_age(::google::protobuf::int32 value);

    // float stop_bar_entrance = 9;
    void clear_stop_bar_entrance();
    static const int kStopBarEntranceFieldNumber = 9;
    float stop_bar_entrance() const;
    void set_stop_bar_entrance(float value);

    // bool stop_bar_valid = 12;
    void clear_stop_bar_valid();
    static const int kStopBarValidFieldNumber = 12;
    bool stop_bar_valid() const;
    void set_stop_bar_valid(bool value);

    // bool available = 13;
    void clear_available();
    static const int kAvailableFieldNumber = 13;
    bool available() const;
    void set_available(bool value);

    // .raincom.apa.msgs.Slot.PLockStatus plock_status = 14;
    void clear_plock_status();
    static const int kPlockStatusFieldNumber = 14;
    ::raincom::apa::msgs::Slot_PLockStatus plock_status() const;
    void set_plock_status(::raincom::apa::msgs::Slot_PLockStatus value);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.Slot)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2> corners_;
    ::raincom::apa::msgs::Header *header_;
    ::raincom::apa::msgs::OBB2d *obb_;
    int type_;
    float conf_;
    ::google::protobuf::int32 age_;
    float stop_bar_entrance_;
    bool stop_bar_valid_;
    bool available_;
    int plock_status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fslot_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SlotFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:raincom.apa.msgs.SlotFrame)
                                                      */
{
  public:
    SlotFrame();
    virtual ~SlotFrame();

    SlotFrame(const SlotFrame &from);

    inline SlotFrame &operator=(const SlotFrame &from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    SlotFrame(SlotFrame &&from) noexcept : SlotFrame() { *this = ::std::move(from); }

    inline SlotFrame &operator=(SlotFrame &&from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual())
        {
            if (this != &from)
                InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const ::google::protobuf::Descriptor *descriptor();
    static const SlotFrame &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const SlotFrame *internal_default_instance()
    {
        return reinterpret_cast<const SlotFrame *>(&_SlotFrame_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    void Swap(SlotFrame *other);
    friend void swap(SlotFrame &a, SlotFrame &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline SlotFrame *New() const final { return CreateMaybeMessage<SlotFrame>(NULL); }

    SlotFrame *New(::google::protobuf::Arena *arena) const final
    {
        return CreateMaybeMessage<SlotFrame>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message &from) final;
    void MergeFrom(const ::google::protobuf::Message &from) final;
    void CopyFrom(const SlotFrame &from);
    void MergeFrom(const SlotFrame &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream *output) const final;
    ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
        bool deterministic, ::google::protobuf::uint8 *target) const final;
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(SlotFrame *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // repeated .raincom.apa.msgs.Slot slot_list = 2;
    int slot_list_size() const;
    void clear_slot_list();
    static const int kSlotListFieldNumber = 2;
    ::raincom::apa::msgs::Slot *mutable_slot_list(int index);
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Slot> *mutable_slot_list();
    const ::raincom::apa::msgs::Slot &slot_list(int index) const;
    ::raincom::apa::msgs::Slot *add_slot_list();
    const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Slot> &slot_list()
        const;

    // .raincom.apa.msgs.Header header = 1;
    bool has_header() const;
    void clear_header();
    static const int kHeaderFieldNumber = 1;

  private:
    const ::raincom::apa::msgs::Header &_internal_header() const;

  public:
    const ::raincom::apa::msgs::Header &header() const;
    ::raincom::apa::msgs::Header *release_header();
    ::raincom::apa::msgs::Header *mutable_header();
    void set_allocated_header(::raincom::apa::msgs::Header *header);

    // @@protoc_insertion_point(class_scope:raincom.apa.msgs.SlotFrame)
  private:
    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Slot> slot_list_;
    ::raincom::apa::msgs::Header *header_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_apa_5fmsgs_2fslot_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Slot

// .raincom.apa.msgs.Header header = 1;
inline bool Slot::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &Slot::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &Slot::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *Slot::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Slot.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *Slot::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Slot.header)
    return header_;
}
inline void Slot::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Slot.header)
}

// .raincom.apa.msgs.Slot.SlotType type = 2;
inline void Slot::clear_type() { type_ = 0; }
inline ::raincom::apa::msgs::Slot_SlotType Slot::type() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.type)
    return static_cast<::raincom::apa::msgs::Slot_SlotType>(type_);
}
inline void Slot::set_type(::raincom::apa::msgs::Slot_SlotType value)
{

    type_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.type)
}

// float conf = 3;
inline void Slot::clear_conf() { conf_ = 0; }
inline float Slot::conf() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.conf)
    return conf_;
}
inline void Slot::set_conf(float value)
{

    conf_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.conf)
}

// int32 age = 4;
inline void Slot::clear_age() { age_ = 0; }
inline ::google::protobuf::int32 Slot::age() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.age)
    return age_;
}
inline void Slot::set_age(::google::protobuf::int32 value)
{

    age_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.age)
}

// .raincom.apa.msgs.OBB2d obb = 5;
inline bool Slot::has_obb() const
{
    return this != internal_default_instance() && obb_ != NULL;
}
inline const ::raincom::apa::msgs::OBB2d &Slot::_internal_obb() const { return *obb_; }
inline const ::raincom::apa::msgs::OBB2d &Slot::obb() const
{
    const ::raincom::apa::msgs::OBB2d *p = obb_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.obb)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::OBB2d *>(
                           &::raincom::apa::msgs::_OBB2d_default_instance_);
}
inline ::raincom::apa::msgs::OBB2d *Slot::release_obb()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.Slot.obb)

    ::raincom::apa::msgs::OBB2d *temp = obb_;
    obb_                              = NULL;
    return temp;
}
inline ::raincom::apa::msgs::OBB2d *Slot::mutable_obb()
{

    if (obb_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::OBB2d>(GetArenaNoVirtual());
        obb_    = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Slot.obb)
    return obb_;
}
inline void Slot::set_allocated_obb(::raincom::apa::msgs::OBB2d *obb)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(obb_);
    }
    if (obb)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            obb = ::google::protobuf::internal::GetOwnedMessage(message_arena, obb,
                                                                submessage_arena);
        }
    }
    else
    {
    }
    obb_ = obb;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.Slot.obb)
}

// repeated .raincom.apa.msgs.Vec2 corners = 6;
inline int Slot::corners_size() const { return corners_.size(); }
inline ::raincom::apa::msgs::Vec2 *Slot::mutable_corners(int index)
{
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.Slot.corners)
    return corners_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
    *Slot::mutable_corners()
{
    // @@protoc_insertion_point(field_mutable_list:raincom.apa.msgs.Slot.corners)
    return &corners_;
}
inline const ::raincom::apa::msgs::Vec2 &Slot::corners(int index) const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.corners)
    return corners_.Get(index);
}
inline ::raincom::apa::msgs::Vec2 *Slot::add_corners()
{
    // @@protoc_insertion_point(field_add:raincom.apa.msgs.Slot.corners)
    return corners_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Vec2>
    &Slot::corners() const
{
    // @@protoc_insertion_point(field_list:raincom.apa.msgs.Slot.corners)
    return corners_;
}

// float stop_bar_entrance = 9;
inline void Slot::clear_stop_bar_entrance() { stop_bar_entrance_ = 0; }
inline float Slot::stop_bar_entrance() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.stop_bar_entrance)
    return stop_bar_entrance_;
}
inline void Slot::set_stop_bar_entrance(float value)
{

    stop_bar_entrance_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.stop_bar_entrance)
}

// bool stop_bar_valid = 12;
inline void Slot::clear_stop_bar_valid() { stop_bar_valid_ = false; }
inline bool Slot::stop_bar_valid() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.stop_bar_valid)
    return stop_bar_valid_;
}
inline void Slot::set_stop_bar_valid(bool value)
{

    stop_bar_valid_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.stop_bar_valid)
}

// bool available = 13;
inline void Slot::clear_available() { available_ = false; }
inline bool Slot::available() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.available)
    return available_;
}
inline void Slot::set_available(bool value)
{

    available_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.available)
}

// .raincom.apa.msgs.Slot.PLockStatus plock_status = 14;
inline void Slot::clear_plock_status() { plock_status_ = 0; }
inline ::raincom::apa::msgs::Slot_PLockStatus Slot::plock_status() const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.Slot.plock_status)
    return static_cast<::raincom::apa::msgs::Slot_PLockStatus>(plock_status_);
}
inline void Slot::set_plock_status(::raincom::apa::msgs::Slot_PLockStatus value)
{

    plock_status_ = value;
    // @@protoc_insertion_point(field_set:raincom.apa.msgs.Slot.plock_status)
}

// -------------------------------------------------------------------

// SlotFrame

// .raincom.apa.msgs.Header header = 1;
inline bool SlotFrame::has_header() const
{
    return this != internal_default_instance() && header_ != NULL;
}
inline const ::raincom::apa::msgs::Header &SlotFrame::_internal_header() const
{
    return *header_;
}
inline const ::raincom::apa::msgs::Header &SlotFrame::header() const
{
    const ::raincom::apa::msgs::Header *p = header_;
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.SlotFrame.header)
    return p != NULL ? *p
                     : *reinterpret_cast<const ::raincom::apa::msgs::Header *>(
                           &::raincom::apa::msgs::_Header_default_instance_);
}
inline ::raincom::apa::msgs::Header *SlotFrame::release_header()
{
    // @@protoc_insertion_point(field_release:raincom.apa.msgs.SlotFrame.header)

    ::raincom::apa::msgs::Header *temp = header_;
    header_                            = NULL;
    return temp;
}
inline ::raincom::apa::msgs::Header *SlotFrame::mutable_header()
{

    if (header_ == NULL)
    {
        auto *p = CreateMaybeMessage<::raincom::apa::msgs::Header>(GetArenaNoVirtual());
        header_ = p;
    }
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.SlotFrame.header)
    return header_;
}
inline void SlotFrame::set_allocated_header(::raincom::apa::msgs::Header *header)
{
    ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
    if (message_arena == NULL)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(header_);
    }
    if (header)
    {
        ::google::protobuf::Arena *submessage_arena = NULL;
        if (message_arena != submessage_arena)
        {
            header = ::google::protobuf::internal::GetOwnedMessage(message_arena, header,
                                                                   submessage_arena);
        }
    }
    else
    {
    }
    header_ = header;
    // @@protoc_insertion_point(field_set_allocated:raincom.apa.msgs.SlotFrame.header)
}

// repeated .raincom.apa.msgs.Slot slot_list = 2;
inline int SlotFrame::slot_list_size() const { return slot_list_.size(); }
inline void SlotFrame::clear_slot_list() { slot_list_.Clear(); }
inline ::raincom::apa::msgs::Slot *SlotFrame::mutable_slot_list(int index)
{
    // @@protoc_insertion_point(field_mutable:raincom.apa.msgs.SlotFrame.slot_list)
    return slot_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Slot>
    *SlotFrame::mutable_slot_list()
{
    // @@protoc_insertion_point(field_mutable_list:raincom.apa.msgs.SlotFrame.slot_list)
    return &slot_list_;
}
inline const ::raincom::apa::msgs::Slot &SlotFrame::slot_list(int index) const
{
    // @@protoc_insertion_point(field_get:raincom.apa.msgs.SlotFrame.slot_list)
    return slot_list_.Get(index);
}
inline ::raincom::apa::msgs::Slot *SlotFrame::add_slot_list()
{
    // @@protoc_insertion_point(field_add:raincom.apa.msgs.SlotFrame.slot_list)
    return slot_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::raincom::apa::msgs::Slot>
    &SlotFrame::slot_list() const
{
    // @@protoc_insertion_point(field_list:raincom.apa.msgs.SlotFrame.slot_list)
    return slot_list_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace msgs
} // namespace apa
} // namespace raincom

namespace google
{
namespace protobuf
{

template <>
struct is_proto_enum<::raincom::apa::msgs::Slot_SlotType> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::raincom::apa::msgs::Slot_SlotType>()
{
    return ::raincom::apa::msgs::Slot_SlotType_descriptor();
}
template <>
struct is_proto_enum<::raincom::apa::msgs::Slot_PLockStatus> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::raincom::apa::msgs::Slot_PLockStatus>()
{
    return ::raincom::apa::msgs::Slot_PLockStatus_descriptor();
}

} // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_apa_5fmsgs_2fslot_2eproto
